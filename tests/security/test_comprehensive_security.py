#!/usr/bin/env python3
"""
++ SACRED COMPREHENSIVE SECURITY TEST SUITE BLESSED BY THE PRIME ARCHITECT ++
========================================================================

Comprehensive security testing suite covering all aspects of the Novel Engine
security framework including authentication, authorization, input validation,
rate limiting, and vulnerability assessments.

++ THROUGH DIVINE TESTING, WE ACHIEVE BLESSED SECURITY VALIDATION ++

Architecture: Multi-layer security testing with automated vulnerability detection
Security Level: Enterprise Grade with OWASP Top 10 Coverage
Sacred Author: Chief Systems Engineer Security-Testing
万机之神保佑此安全测试套件 (May the Prime Architect bless this security test suite)
"""

import asyncio
import secrets
import sys
import time
from datetime import datetime, timedelta
from pathlib import Path

import httpx
import jwt
import pytest
import pytest_asyncio

sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from src.api.main_api_server import create_app
from src.security.auth_system import AuthenticationManager, Permission, UserRole
from src.security.input_validation import InputType, InputValidator, ValidationError
from src.security.rate_limiting import (
    InMemoryRateLimitBackend,
    RateLimitMiddleware,
    RateLimitStrategy,
)
from src.security.security_headers import (
    SecurityHeaders,
    get_production_security_config,
)

# Test constants
TEST_JWT_SECRET = "test_secret_key_for_security_testing"
TEST_DATABASE_PATH = ":memory:"


class SecurityTestSuite:
    """++ SACRED SECURITY TEST SUITE ++"""

    def __init__(self):
        self.app = None
        self.client = None
        self.auth_manager = None
        self.test_users = {}

    async def setup(self):
        """Setup test environment"""
        # Create test app
        self.app = create_app()

        # Setup authentication manager
        self.auth_manager = AuthenticationManager(
            database_path=TEST_DATABASE_PATH, jwt_secret=TEST_JWT_SECRET
        )
        await self.auth_manager.initialize()

        # Create test users
        await self._create_test_users()

        # Setup HTTP client
        self.client = httpx.AsyncClient(app=self.app, base_url="http://testserver")

    async def _create_test_users(self):
        """Create test users for different roles"""
        test_users = [
            ("admin_user", "admin@test.com", "SecurePass123!", UserRole.ADMIN),
            ("moderator_user", "mod@test.com", "SecurePass123!", UserRole.MODERATOR),
            (
                "creator_user",
                "creator@test.com",
                "SecurePass123!",
                UserRole.CONTENT_CREATOR,
            ),
            ("api_user", "api@test.com", "SecurePass123!", UserRole.API_USER),
            ("reader_user", "reader@test.com", "SecurePass123!", UserRole.READER),
        ]

        for username, email, password, role in test_users:
            try:
                user_result = await self.auth_manager.create_user(
                    username=username, email=email, password=password, role=role
                )
                if user_result.success:
                    self.test_users[username] = {
                        "user_id": user_result.data["user_id"],
                        "email": email,
                        "password": password,
                        "role": role,
                    }
            except Exception as e:
                print(f"Error creating test user {username}: {e}")

    async def teardown(self):
        """Cleanup test environment"""
        if self.client:
            await self.client.aclose()
        if self.auth_manager:
            await self.auth_manager.close()


@pytest.mark.asyncio
class TestAuthentication:
    """++ SACRED AUTHENTICATION SECURITY TESTS ++"""

    @pytest_asyncio.fixture
    async def security_suite(self):
        suite = SecurityTestSuite()
        await suite.setup()
        yield suite
        await suite.teardown()

    async def test_jwt_token_validation(self, security_suite):
        """Test JWT token validation and security"""
        auth_manager = security_suite.auth_manager

        # Test valid token generation
        user_data = security_suite.test_users["admin_user"]
        login_result = await auth_manager.authenticate_user(
            user_data["email"], user_data["password"]
        )

        assert login_result.success
        assert "access_token" in login_result.data
        assert "refresh_token" in login_result.data

        # Test token validation
        access_token = login_result.data["access_token"]
        validation_result = await auth_manager.validate_token(access_token)

        assert validation_result.success
        assert validation_result.data["user_id"] == user_data["user_id"]

    async def test_password_security_requirements(self, security_suite):
        """Test password security requirements"""
        auth_manager = security_suite.auth_manager

        # Test weak passwords (should fail)
        weak_passwords = [
            "123456",  # Too short
            "password",  # Common password
            "12345678",  # Numbers only
            "abcdefgh",  # Letters only
            "Password",  # Missing numbers/symbols
        ]

        for weak_password in weak_passwords:
            with pytest.raises(Exception):  # Should raise validation error
                await auth_manager.create_user(
                    username=f"test_weak_{secrets.token_hex(4)}",
                    email=f"weak_{secrets.token_hex(4)}@test.com",
                    password=weak_password,
                    role=UserRole.READER,
                )

    async def test_brute_force_protection(self, security_suite):
        """Test brute force attack protection"""
        auth_manager = security_suite.auth_manager
        user_data = security_suite.test_users["reader_user"]

        # Attempt multiple failed logins
        for i in range(6):  # Exceed max login attempts
            result = await auth_manager.authenticate_user(
                user_data["email"], "wrong_password"
            )
            assert not result.success

        # Account should now be locked
        result = await auth_manager.authenticate_user(
            user_data["email"], user_data["password"]  # Correct password
        )
        assert not result.success
        assert "locked" in result.error.message.lower()

    async def test_token_expiration(self, security_suite):
        """Test JWT token expiration handling"""
        auth_manager = security_suite.auth_manager

        # Create a token with short expiration
        user_id = security_suite.test_users["admin_user"]["user_id"]
        expired_token = jwt.encode(
            {
                "user_id": user_id,
                "exp": datetime.utcnow() - timedelta(minutes=1),  # Expired
            },
            TEST_JWT_SECRET,
            algorithm="HS256",
        )

        # Validation should fail for expired token
        result = await auth_manager.validate_token(expired_token)
        assert not result.success
        assert "expired" in result.error.message.lower()


@pytest.mark.asyncio
class TestAuthorization:
    """++ SACRED AUTHORIZATION SECURITY TESTS ++"""

    @pytest_asyncio.fixture
    async def security_suite(self):
        suite = SecurityTestSuite()
        await suite.setup()
        yield suite
        await suite.teardown()

    async def test_role_based_access_control(self, security_suite):
        """Test role-based access control enforcement"""
        auth_manager = security_suite.auth_manager

        # Test admin permissions
        admin_user = security_suite.test_users["admin_user"]
        assert auth_manager.has_permission(admin_user["role"], Permission.SYSTEM_ADMIN)
        assert auth_manager.has_permission(admin_user["role"], Permission.USER_DELETE)

        # Test reader permissions
        reader_user = security_suite.test_users["reader_user"]
        assert not auth_manager.has_permission(
            reader_user["role"], Permission.SYSTEM_ADMIN
        )
        assert not auth_manager.has_permission(
            reader_user["role"], Permission.USER_DELETE
        )
        assert auth_manager.has_permission(reader_user["role"], Permission.STORY_READ)

    async def test_permission_escalation_prevention(self, security_suite):
        """Test prevention of privilege escalation"""
        auth_manager = security_suite.auth_manager

        # Creator should not have admin permissions
        creator_user = security_suite.test_users["creator_user"]
        assert not auth_manager.has_permission(
            creator_user["role"], Permission.SYSTEM_ADMIN
        )
        assert not auth_manager.has_permission(
            creator_user["role"], Permission.USER_MANAGE_ROLES
        )

        # API user should not have content creation permissions
        api_user = security_suite.test_users["api_user"]
        assert not auth_manager.has_permission(
            api_user["role"], Permission.STORY_CREATE
        )
        assert not auth_manager.has_permission(
            api_user["role"], Permission.CHARACTER_CREATE
        )


class TestInputValidation:
    """++ SACRED INPUT VALIDATION SECURITY TESTS ++"""

    @pytest.fixture
    def input_validator(self):
        return InputValidator()

    def test_sql_injection_detection(self, input_validator):
        """Test SQL injection detection"""
        malicious_inputs = [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "UNION SELECT * FROM passwords",
            "'; INSERT INTO admin VALUES ('hacker'); --",
            "1' UNION SELECT null, username, password FROM users--",
        ]

        for malicious_input in malicious_inputs:
            with pytest.raises(ValidationError) as exc_info:
                input_validator.validate_input(malicious_input, InputType.TEXT)

            assert exc_info.value.severity.value in ["high", "critical"]
            assert (
                "sql" in exc_info.value.message.lower()
                or "injection" in exc_info.value.message.lower()
            )

    def test_xss_detection(self, input_validator):
        """Test XSS attack detection"""
        xss_payloads = [
            "<script>alert('xss')</script>",
            "javascript:alert('xss')",
            "<img src=x onerror=alert('xss')>",
            "<iframe src='javascript:alert(\"xss\")'></iframe>",
            "<svg onload=alert('xss')>",
        ]

        for xss_payload in xss_payloads:
            with pytest.raises(ValidationError) as exc_info:
                input_validator.validate_input(xss_payload, InputType.HTML)

            assert exc_info.value.severity.value in ["medium", "high"]
            assert "xss" in exc_info.value.message.lower()

    def test_command_injection_detection(self, input_validator):
        """Test command injection detection"""
        command_payloads = [
            "; cat /etc/passwd",
            "| ls -la",
            "&& rm -rf /",
            "`whoami`",
            "$(id)",
            "../../../etc/passwd",
        ]

        for command_payload in command_payloads:
            with pytest.raises(ValidationError) as exc_info:
                input_validator.validate_input(command_payload, InputType.FILENAME)

            assert exc_info.value.severity.value in ["medium", "high"]

    def test_input_sanitization(self, input_validator):
        """Test input sanitization functionality"""
        # Test HTML escaping
        html_input = "<script>alert('test')</script>"
        try:
            sanitized = input_validator.validate_input(html_input, InputType.TEXT)
            # Should either be sanitized or raise an exception
            assert "&lt;" in sanitized or "&gt;" in sanitized
        except ValidationError:
            # Blocking is also acceptable for malicious input
            pass

        # Test whitespace stripping
        whitespace_input = "  normal text  "
        sanitized = input_validator.validate_input(whitespace_input, InputType.USERNAME)
        assert sanitized == "normal text"


@pytest.mark.asyncio
class TestRateLimiting:
    """++ SACRED RATE LIMITING SECURITY TESTS ++"""

    @pytest_asyncio.fixture
    async def rate_limiter(self):
        backend = InMemoryRateLimitBackend()
        strategy = RateLimitStrategy()
        return RateLimitMiddleware(None, backend, strategy)

    async def test_rate_limit_enforcement(self, rate_limiter):
        """Test rate limit enforcement"""
        backend = rate_limiter.backend

        # Create a strict rate limit for testing
        from src.security.rate_limiting import RateLimit

        test_limit = RateLimit(requests=5, window=60)

        # Make requests up to the limit
        for i in range(5):
            result = await backend.check_rate_limit("test_key", test_limit)
            assert result.allowed
            assert result.remaining == (4 - i)

        # Next request should be rate limited
        result = await backend.check_rate_limit("test_key", test_limit)
        assert not result.allowed
        assert result.remaining == 0
        assert result.retry_after > 0

    async def test_ddos_detection(self, rate_limiter):
        """Test DDoS attack detection"""
        ddos_detector = rate_limiter.ddos_detector

        if ddos_detector:
            # Simulate high-frequency requests
            for i in range(600):  # Exceed attack threshold
                is_allowed, reason = await ddos_detector.analyze_request(
                    "192.168.1.100"
                )
                if not is_allowed:
                    assert "attack" in reason.lower() or "blocked" in reason.lower()
                    break
            else:
                pytest.fail("DDoS detection did not trigger")

    async def test_ip_whitelist(self, rate_limiter):
        """Test IP whitelist functionality"""
        whitelist = rate_limiter.whitelist

        # Test localhost IPs (should be whitelisted)
        assert whitelist.is_whitelisted("127.0.0.1")
        assert whitelist.is_whitelisted("::1")
        assert whitelist.is_whitelisted("192.168.1.100")  # Private network

        # Test external IPs (should not be whitelisted by default)
        assert not whitelist.is_whitelisted("8.8.8.8")
        assert not whitelist.is_whitelisted("1.1.1.1")


class TestSecurityHeaders:
    """++ SACRED SECURITY HEADERS TESTS ++"""

    def test_security_headers_configuration(self):
        """Test security headers configuration"""
        config = get_production_security_config()
        headers = SecurityHeaders(config)

        # Test CSP header
        csp_header = headers.get_header("Content-Security-Policy")
        assert csp_header is not None
        assert "default-src 'self'" in csp_header

        # Test HSTS header
        hsts_header = headers.get_header("Strict-Transport-Security")
        assert hsts_header is not None
        assert "max-age=" in hsts_header
        assert "includeSubDomains" in hsts_header

        # Test other security headers
        assert headers.get_header("X-Frame-Options") == "DENY"
        assert headers.get_header("X-Content-Type-Options") == "nosniff"
        assert headers.get_header("X-XSS-Protection") == "1; mode=block"


@pytest.mark.asyncio
class TestVulnerabilityAssessment:
    """++ SACRED VULNERABILITY ASSESSMENT TESTS ++"""

    @pytest_asyncio.fixture
    async def security_suite(self):
        suite = SecurityTestSuite()
        await suite.setup()
        yield suite
        await suite.teardown()

    async def test_owasp_top_10_protection(self, security_suite):
        """Test protection against OWASP Top 10 vulnerabilities"""

        # A1: Injection - Covered by input validation tests
        # A2: Broken Authentication - Covered by authentication tests
        # A3: Sensitive Data Exposure - Test encryption and secure headers

        # Test secure headers
        response = await security_suite.client.get("/")
        assert "X-Content-Type-Options" in response.headers
        assert "X-Frame-Options" in response.headers

        # A4: XML External Entities (XXE) - Test XML parsing safety
        if hasattr(security_suite.client, "post"):
            xxe_payload = """<?xml version="1.0" encoding="ISO-8859-1"?>
            <!DOCTYPE foo [
            <!ELEMENT foo ANY >
            <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
            <foo>&xxe;</foo>"""

            response = await security_suite.client.post(
                "/api/v1/stories",
                content=xxe_payload,
                headers={"Content-Type": "application/xml"},
            )
            # Should reject malicious XML
            assert response.status_code in [400, 403, 415, 422]

        # A5: Broken Access Control - Covered by authorization tests
        # A6: Security Misconfiguration - Test secure defaults
        # A7: Cross-Site Scripting (XSS) - Covered by input validation tests
        # A8: Insecure Deserialization - Test secure JSON parsing
        # A9: Using Components with Known Vulnerabilities - Manual review required
        # A10: Insufficient Logging & Monitoring - Test security logging

    async def test_information_disclosure_prevention(self, security_suite):
        """Test prevention of information disclosure"""

        # Test error handling doesn't expose sensitive information
        response = await security_suite.client.get("/nonexistent-endpoint")
        assert response.status_code == 404

        # Response should not contain stack traces or internal paths
        response_text = response.text.lower()
        assert "traceback" not in response_text
        assert "exception" not in response_text
        assert "/home/" not in response_text
        assert "c:\\" not in response_text

    async def test_session_security(self, security_suite):
        """Test session security measures"""
        auth_manager = security_suite.auth_manager
        user_data = security_suite.test_users["admin_user"]

        # Test secure token generation
        login_result = await auth_manager.authenticate_user(
            user_data["email"], user_data["password"]
        )

        assert login_result.success
        access_token = login_result.data["access_token"]
        refresh_token = login_result.data["refresh_token"]

        # Tokens should be different
        assert access_token != refresh_token

        # Tokens should have sufficient entropy (length check)
        assert len(access_token) > 100  # JWT tokens should be long
        assert len(refresh_token) > 32  # Refresh tokens should be random


@pytest.mark.asyncio
class TestSecurityMonitoring:
    """++ SACRED SECURITY MONITORING TESTS ++"""

    async def test_security_event_logging(self):
        """Test security event logging functionality"""
        # This would test the security logging system
        # Implementation depends on the logging backend
        pass

    async def test_audit_trail(self):
        """Test audit trail functionality"""
        # This would test audit logging for sensitive operations
        # Implementation depends on the audit logging system
        pass


# Performance and Load Testing
@pytest.mark.asyncio
class TestSecurityPerformance:
    """++ SACRED SECURITY PERFORMANCE TESTS ++"""

    async def test_rate_limiting_performance(self):
        """Test rate limiting system performance under load"""
        backend = InMemoryRateLimitBackend()
        from src.security.rate_limiting import RateLimit

        test_limit = RateLimit(requests=1000, window=60)

        # Measure performance of rate limit checks

        start_time = time.time()

        tasks = []
        for i in range(1000):
            task = backend.check_rate_limit(f"key_{i%100}", test_limit)
            tasks.append(task)

        results = await asyncio.gather(*tasks)
        end_time = time.time()

        # Should complete 1000 rate limit checks in reasonable time
        duration = end_time - start_time
        assert duration < 1.0  # Less than 1 second for 1000 checks

        # All should be allowed (within rate limit)
        assert all(result.allowed for result in results)

    async def test_input_validation_performance(self):
        """Test input validation performance"""
        validator = InputValidator()

        # Test with normal input
        normal_input = "This is normal text content" * 10

        start_time = time.time()

        for _ in range(1000):
            validator.validate_input(normal_input, InputType.TEXT)

        end_time = time.time()
        duration = end_time - start_time

        # Should validate 1000 inputs quickly
        assert duration < 0.5  # Less than 500ms for 1000 validations


# Integration Tests
@pytest.mark.asyncio
class TestSecurityIntegration:
    """++ SACRED SECURITY INTEGRATION TESTS ++"""

    @pytest_asyncio.fixture
    async def security_suite(self):
        suite = SecurityTestSuite()
        await suite.setup()
        yield suite
        await suite.teardown()

    async def test_end_to_end_security_flow(self, security_suite):
        """Test complete security flow from authentication to authorization"""

        # 1. Authenticate user
        user_data = security_suite.test_users["creator_user"]
        login_result = await security_suite.auth_manager.authenticate_user(
            user_data["email"], user_data["password"]
        )

        assert login_result.success
        access_token = login_result.data["access_token"]

        # 2. Make authenticated request with proper headers
        headers = {"Authorization": f"Bearer {access_token}"}
        response = await security_suite.client.get(
            "/api/v1/characters", headers=headers
        )

        # Should succeed with proper authentication
        assert response.status_code in [200, 404]  # 404 is ok if no characters exist

        # 3. Test unauthorized access
        response = await security_suite.client.get("/api/v1/characters")

        # Should require authentication
        assert response.status_code in [401, 403]


if __name__ == "__main__":
    # Run the security test suite
    pytest.main([__file__, "-v", "--tb=short"])
