## ADDED Requirements

### Requirement: Real-time event streaming endpoint
Backend API MUST provide Server-Sent Events (SSE) endpoint at `/api/v1/events/stream` that streams real-time dashboard events following the canonical `/api/v1/*` versioning pattern.

#### Scenario: SSE endpoint returns event stream
- **GIVEN** a client connects to `/api/v1/events/stream` with `Accept: text/event-stream` header
- **WHEN** the endpoint processes the request
- **THEN** it responds with HTTP 200, `Content-Type: text/event-stream`, `Cache-Control: no-cache`, and `Connection: keep-alive` headers, and begins streaming events in SSE format

#### Scenario: Events follow required payload structure
- **GIVEN** an event is generated by the backend event system
- **WHEN** the event is serialized and sent via SSE
- **THEN** the event data includes required fields: `id` (string/number), `type` (enum: 'character' | 'story' | 'system' | 'interaction'), `title` (string), `description` (string), `timestamp` (number in milliseconds), `severity` (enum: 'low' | 'medium' | 'high'), and optional field: `characterName` (string)

#### Scenario: SSE stream includes retry directive
- **GIVEN** a new SSE connection is established
- **WHEN** the first message is sent to the client
- **THEN** the stream includes a `retry: 3000` directive (in milliseconds) to instruct the client's reconnection interval

#### Scenario: Stream handles client disconnection gracefully
- **GIVEN** a client is connected to the event stream
- **WHEN** the client closes the connection or network is interrupted
- **THEN** the backend detects the disconnection via `asyncio.CancelledError`, cleans up resources, and terminates the generator without crashing

#### Scenario: Stream continues on internal errors
- **GIVEN** an error occurs during event generation (e.g., database query fails)
- **WHEN** the exception is caught by the event generator
- **THEN** the stream sends an error event with `type: "system"`, `severity: "high"`, and error description, logs the error, and continues streaming subsequent events without terminating the connection

### Requirement: Event generation and delivery
Backend MUST generate events from application state changes and deliver them to connected SSE clients in real-time.

#### Scenario: Events are generated from system activity
- **GIVEN** a significant application event occurs (character action, story progression, system alert, user interaction)
- **WHEN** the event is processed by the event store/message queue
- **THEN** a corresponding event is created with unique ID, appropriate type, descriptive title/description, current timestamp, and severity level, and queued for delivery to SSE clients

#### Scenario: Events are delivered to all connected clients
- **GIVEN** multiple clients are connected to `/api/v1/events/stream`
- **WHEN** a new event is added to the event queue
- **THEN** the event is delivered to all active SSE connections within 2 seconds of generation

#### Scenario: Events maintain chronological order
- **GIVEN** events are generated with sequential IDs (evt-1, evt-2, evt-3)
- **WHEN** events are streamed to clients
- **THEN** clients receive events in the same chronological order they were generated, with no out-of-order delivery

### Requirement: SSE endpoint observability
Backend MUST provide logging and monitoring for SSE connections and event delivery.

#### Scenario: Connection lifecycle is logged
- **GIVEN** a client connects to or disconnects from `/api/v1/events/stream`
- **WHEN** the connection state changes
- **THEN** the backend logs the event with timestamp, client identifier (IP/session), and connection state (connected/disconnected)

#### Scenario: Event delivery errors are logged
- **GIVEN** an event fails to serialize or send to a client
- **WHEN** the error is caught
- **THEN** the backend logs the error with event ID, client identifier, error message, and stack trace, and increments an error counter for monitoring

#### Scenario: Active connection count is trackable
- **GIVEN** SSE connections are established and terminated
- **WHEN** monitoring tools query connection metrics
- **THEN** the backend exposes the current count of active SSE connections via logging or metrics endpoint
