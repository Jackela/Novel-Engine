"""
Modular Interaction Engine - Main Facade
========================================

Unified interface for the modular interaction engine system maintaining
backward compatibility while providing enhanced enterprise-grade functionality.
"""

import logging
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union, Callable

# Import modular components
from .core.types import (
    InteractionContext, InteractionType, InteractionPriority,
    InteractionPhase, InteractionOutcome, InteractionEngineConfig
)
from .validation.interaction_validator import InteractionValidator
from .processing.interaction_processor import InteractionProcessor
from .type_processors.interaction_type_processors import InteractionTypeProcessorManager
from .state_management.state_manager import StateManager
from .queue_management.queue_manager import QueueManager

# Import enhanced core systems
try:
    from src.core.data_models import (
        StandardResponse, ErrorInfo, CharacterState, MemoryItem, 
        CharacterInteraction, InteractionResult
    )
    from src.core.types import AgentID
    from src.core.memory_system import MemoryManager
    from src.core.character_manager import CharacterManager
    from src.core.equipment_manager import EquipmentManager
except ImportError:
    # Fallback for testing
    class StandardResponse:
        def __init__(self, success=True, data=None, error=None, metadata=None):
            self.success = success
            self.data = data or {}
            self.error = error
            self.metadata = metadata or {}
        
        def get(self, key, default=None):
            return getattr(self, key, default)
        
        def __getitem__(self, key):
            return getattr(self, key)
    
    class ErrorInfo:
        def __init__(self, code="", message="", recoverable=True):
            self.code = code
            self.message = message
            self.recoverable = recoverable
    
    CharacterState = dict
    MemoryItem = dict
    CharacterInteraction = dict
    InteractionResult = dict
    AgentID = str
    MemoryManager = None
    CharacterManager = None
    EquipmentManager = None

__all__ = ['InteractionEngine', 'create_interaction_engine', 'create_performance_optimized_config']


class InteractionEngine:
    """
    Modular Interaction Engine - Main Facade
    
    Enterprise-grade interaction processing engine with comprehensive
    character interaction capabilities, state management, and extensible
    architecture.
    
    Features:
    - Multi-type interaction processing (dialogue, combat, cooperation, etc.)
    - Comprehensive validation and prerequisite checking
    - Advanced state management and memory integration
    - Priority-based queue management and scheduling
    - Performance monitoring and detailed logging
    - Backward compatibility with original interface
    """\n    \n    def __init__(self, config: Optional[InteractionEngineConfig] = None,\n                 memory_manager: Optional[Any] = None,\n                 character_manager: Optional[Any] = None,\n                 equipment_manager: Optional[Any] = None,\n                 logger: Optional[logging.Logger] = None):\n        \"\"\"\n        Initialize modular interaction engine.\n        \n        Args:\n            config: Interaction engine configuration\n            memory_manager: Optional memory manager instance\n            character_manager: Optional character manager instance\n            equipment_manager: Optional equipment manager instance\n            logger: Optional logger instance\n        \"\"\"\n        self.config = config or InteractionEngineConfig()\n        self.memory_manager = memory_manager\n        self.character_manager = character_manager\n        self.equipment_manager = equipment_manager\n        self.logger = logger or logging.getLogger(__name__)\n        \n        # Initialize modular components\n        self.validator = InteractionValidator(self.config, self.logger)\n        self.processor = InteractionProcessor(\n            self.config, self.memory_manager, self.character_manager, self.logger\n        )\n        self.type_processors = InteractionTypeProcessorManager(self.config, self.logger)\n        self.state_manager = StateManager(\n            self.config, self.memory_manager, self.character_manager, self.logger\n        )\n        self.queue_manager = QueueManager(self.config, self.logger)\n        \n        # Engine state\n        self.is_initialized = False\n        self.processing_active = False\n        \n        # Statistics tracking\n        self.engine_stats = {\n            \"total_interactions_processed\": 0,\n            \"successful_interactions\": 0,\n            \"failed_interactions\": 0,\n            \"average_processing_time\": 0.0,\n            \"startup_time\": datetime.now(),\n            \"uptime_seconds\": 0.0\n        }\n        \n        # Initialize engine\n        asyncio.create_task(self._initialize_engine())\n        \n        self.logger.info(\"Modular interaction engine initialized\")\n    \n    async def _initialize_engine(self):\n        \"\"\"Initialize engine components.\"\"\"\n        try:\n            # Start queue processing\n            await self.queue_manager.start_queue_processing()\n            \n            self.is_initialized = True\n            self.processing_active = True\n            \n            self.logger.info(\"Interaction engine initialization completed\")\n            \n        except Exception as e:\n            self.logger.error(f\"Engine initialization failed: {e}\")\n    \n    # Core interaction processing methods\n    \n    async def process_interaction(self, context: InteractionContext,\n                                 async_processing: bool = False) -> Union[InteractionOutcome, StandardResponse]:\n        \"\"\"\n        Process a complete interaction through the modular engine.\n        \n        Args:\n            context: Interaction context to process\n            async_processing: Whether to process asynchronously via queue\n            \n        Returns:\n            InteractionOutcome for sync processing or StandardResponse for async\n        \"\"\"\n        try:\n            if not self.is_initialized:\n                await self._initialize_engine()\n            \n            self.logger.info(f\"Processing interaction: {context.interaction_id}\")\n            \n            if async_processing:\n                # Queue for asynchronous processing\n                return await self._queue_interaction(context)\n            else:\n                # Process synchronously\n                return await self._process_interaction_sync(context)\n                \n        except Exception as e:\n            self.logger.error(f\"Interaction processing failed: {e}\")\n            return InteractionOutcome(\n                interaction_id=context.interaction_id,\n                context=context,\n                success=False,\n                errors=[f\"Processing failed: {str(e)}\"]\n            )\n    \n    async def _process_interaction_sync(self, context: InteractionContext) -> InteractionOutcome:\n        \"\"\"Process interaction synchronously through all phases.\"\"\"\n        processing_start = datetime.now()\n        \n        try:\n            # Phase 1: Validation\n            validation_result = await self.validator.validate_interaction_context(context)\n            if not validation_result.success:\n                return InteractionOutcome(\n                    interaction_id=context.interaction_id,\n                    context=context,\n                    success=False,\n                    errors=[f\"Validation failed: {validation_result.error.message if validation_result.error else 'Unknown error'}\"]\n                )\n            \n            # Phase 2: Prerequisite checking\n            if context.prerequisites:\n                prereq_result = await self.validator.check_prerequisites(context)\n                if not prereq_result.success and self.config.strict_prerequisite_checking:\n                    return InteractionOutcome(\n                        interaction_id=context.interaction_id,\n                        context=context,\n                        success=False,\n                        errors=[f\"Prerequisites not met: {prereq_result.error.message if prereq_result.error else 'Unknown error'}\"]\n                    )\n            \n            # Phase 3: Type-specific processing\n            type_processing_result = await self.type_processors.process_interaction(context)\n            if not type_processing_result.success:\n                return InteractionOutcome(\n                    interaction_id=context.interaction_id,\n                    context=context,\n                    success=False,\n                    errors=[f\"Type processing failed: {type_processing_result.error.message if type_processing_result.error else 'Unknown error'}\"]\n                )\n            \n            # Phase 4: State updates\n            if self.config.memory_integration_enabled or self.config.validate_participant_states:\n                state_result = await self.state_manager.update_interaction_states(\n                    context, type_processing_result.data\n                )\n                if not state_result.success:\n                    self.logger.warning(f\"State update failed: {state_result.error}\")\n            \n            # Create successful outcome\n            processing_time = (datetime.now() - processing_start).total_seconds()\n            \n            outcome = InteractionOutcome(\n                interaction_id=context.interaction_id,\n                context=context,\n                success=True,\n                processing_duration=processing_time,\n                interaction_content=type_processing_result.data,\n                completed_phases=[\"validation\", \"prerequisites\", \"processing\", \"state_update\"]\n            )\n            \n            # Update engine statistics\n            self._update_engine_stats(True, processing_time)\n            \n            self.logger.info(f\"Interaction completed successfully: {context.interaction_id} ({processing_time:.2f}s)\")\n            \n            return outcome\n            \n        except Exception as e:\n            processing_time = (datetime.now() - processing_start).total_seconds()\n            self._update_engine_stats(False, processing_time)\n            \n            self.logger.error(f\"Synchronous processing failed: {e}\")\n            \n            return InteractionOutcome(\n                interaction_id=context.interaction_id,\n                context=context,\n                success=False,\n                processing_duration=processing_time,\n                errors=[f\"Processing exception: {str(e)}\"]\n            )\n    \n    async def _queue_interaction(self, context: InteractionContext) -> StandardResponse:\n        \"\"\"Queue interaction for asynchronous processing.\"\"\"\n        try:\n            # Define processing callback\n            async def processing_callback(ctx: InteractionContext):\n                self.logger.info(f\"Started processing queued interaction: {ctx.interaction_id}\")\n            \n            # Define completion callback\n            async def completion_callback(ctx: InteractionContext):\n                self.logger.info(f\"Completed processing queued interaction: {ctx.interaction_id}\")\n            \n            # Queue the interaction\n            return await self.queue_manager.queue_interaction(\n                context,\n                processing_callback=processing_callback,\n                completion_callback=completion_callback\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Failed to queue interaction: {e}\")\n            return StandardResponse(\n                success=False,\n                error=ErrorInfo(\n                    code=\"QUEUE_FAILED\",\n                    message=f\"Failed to queue interaction: {str(e)}\",\n                    recoverable=True\n                )\n            )\n    \n    # Backward compatibility methods\n    \n    async def create_character_interaction(self, agent_id: str, target_id: str,\n                                         interaction_type: str, content: Dict[str, Any],\n                                         priority: str = \"normal\") -> StandardResponse:\n        \"\"\"\n        Backward compatible method for creating character interactions.\n        \n        Args:\n            agent_id: ID of initiating agent\n            target_id: ID of target agent  \n            interaction_type: Type of interaction\n            content: Interaction content\n            priority: Interaction priority\n            \n        Returns:\n            StandardResponse with interaction results\n        \"\"\"\n        try:\n            # Convert to new interaction context format\n            context = InteractionContext(\n                interaction_id=f\"{agent_id}_{target_id}_{datetime.now().timestamp()}\",\n                interaction_type=InteractionType(interaction_type.lower()),\n                priority=InteractionPriority(priority.lower()),\n                participants=[agent_id, target_id],\n                initiator=agent_id,\n                metadata=content\n            )\n            \n            # Process interaction\n            outcome = await self.process_interaction(context)\n            \n            # Convert outcome to legacy format\n            return StandardResponse(\n                success=outcome.success,\n                data={\n                    \"interaction_id\": outcome.interaction_id,\n                    \"content\": outcome.interaction_content,\n                    \"processing_time\": outcome.processing_duration,\n                    \"participants\": outcome.context.participants\n                },\n                metadata={\"blessing\": \"character_interaction_created\"}\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Character interaction creation failed: {e}\")\n            return StandardResponse(\n                success=False,\n                error=ErrorInfo(\n                    code=\"INTERACTION_CREATION_FAILED\",\n                    message=f\"Failed to create character interaction: {str(e)}\",\n                    recoverable=True\n                )\n            )\n    \n    async def handle_dialogue_request(self, requester_id: str, target_id: str,\n                                    dialogue_content: str, context_data: Dict[str, Any] = None) -> StandardResponse:\n        \"\"\"\n        Backward compatible dialogue handling.\n        \n        Args:\n            requester_id: ID of requesting agent\n            target_id: ID of target agent\n            dialogue_content: Dialogue content\n            context_data: Optional context data\n            \n        Returns:\n            StandardResponse with dialogue results\n        \"\"\"\n        try:\n            context = InteractionContext(\n                interaction_id=f\"dialogue_{requester_id}_{target_id}_{datetime.now().timestamp()}\",\n                interaction_type=InteractionType.DIALOGUE,\n                priority=InteractionPriority.NORMAL,\n                participants=[requester_id, target_id],\n                initiator=requester_id,\n                metadata={\"dialogue_content\": dialogue_content, **(context_data or {})}\n            )\n            \n            outcome = await self.process_interaction(context)\n            \n            return StandardResponse(\n                success=outcome.success,\n                data={\n                    \"dialogue_result\": outcome.interaction_content,\n                    \"participants\": [requester_id, target_id],\n                    \"dialogue_content\": dialogue_content\n                },\n                metadata={\"blessing\": \"dialogue_processed\"}\n            )\n            \n        except Exception as e:\n            return StandardResponse(\n                success=False,\n                error=ErrorInfo(\n                    code=\"DIALOGUE_FAILED\",\n                    message=f\"Dialogue processing failed: {str(e)}\",\n                    recoverable=True\n                )\n            )\n    \n    # Monitoring and management methods\n    \n    def get_engine_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive engine status.\"\"\"\n        current_time = datetime.now()\n        uptime = (current_time - self.engine_stats[\"startup_time\"]).total_seconds()\n        \n        return {\n            \"engine_status\": {\n                \"initialized\": self.is_initialized,\n                \"processing_active\": self.processing_active,\n                \"uptime_seconds\": uptime,\n                **self.engine_stats\n            },\n            \"queue_status\": self.queue_manager.get_queue_status(),\n            \"processor_statistics\": self.type_processors.get_processor_statistics(),\n            \"state_manager_stats\": self.state_manager.get_state_statistics(),\n            \"supported_interaction_types\": [t.value for t in self.type_processors.get_supported_types()]\n        }\n    \n    async def shutdown_engine(self) -> StandardResponse:\n        \"\"\"Gracefully shutdown the engine.\"\"\"\n        try:\n            self.logger.info(\"Shutting down interaction engine\")\n            \n            # Stop queue processing\n            await self.queue_manager.stop_queue_processing()\n            \n            # Clear any pending operations\n            await self.queue_manager.clear_queue()\n            \n            self.processing_active = False\n            self.is_initialized = False\n            \n            return StandardResponse(\n                success=True,\n                data={\"status\": \"shutdown_complete\"},\n                metadata={\"blessing\": \"engine_shutdown\"}\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Engine shutdown failed: {e}\")\n            return StandardResponse(\n                success=False,\n                error=ErrorInfo(\n                    code=\"SHUTDOWN_FAILED\",\n                    message=f\"Engine shutdown failed: {str(e)}\",\n                    recoverable=False\n                )\n            )\n    \n    def validate_interaction_context(self, context: InteractionContext) -> StandardResponse:\n        \"\"\"Validate interaction context without processing.\"\"\"\n        try:\n            # Use validator for context validation\n            return asyncio.run(self.validator.validate_interaction_context(context))\n        except Exception as e:\n            return StandardResponse(\n                success=False,\n                error=ErrorInfo(\n                    code=\"VALIDATION_ERROR\",\n                    message=f\"Context validation failed: {str(e)}\",\n                    recoverable=True\n                )\n            )\n    \n    def calculate_interaction_risk(self, context: InteractionContext) -> Dict[str, Any]:\n        \"\"\"Calculate risk assessment for interaction.\"\"\"\n        try:\n            return self.validator.calculate_risk_assessment(context)\n        except Exception as e:\n            return {\"risk_score\": 0.5, \"risk_level\": \"Unknown\", \"error\": str(e)}\n    \n    # Private helper methods\n    \n    def _update_engine_stats(self, success: bool, processing_time: float):\n        \"\"\"Update engine processing statistics.\"\"\"\n        self.engine_stats[\"total_interactions_processed\"] += 1\n        \n        if success:\n            self.engine_stats[\"successful_interactions\"] += 1\n        else:\n            self.engine_stats[\"failed_interactions\"] += 1\n        \n        # Update average processing time\n        total_processed = self.engine_stats[\"total_interactions_processed\"]\n        current_avg = self.engine_stats[\"average_processing_time\"]\n        \n        self.engine_stats[\"average_processing_time\"] = (\n            (current_avg * (total_processed - 1)) + processing_time\n        ) / total_processed\n    \n    def __del__(self):\n        \"\"\"Cleanup on destruction.\"\"\"\n        try:\n            asyncio.create_task(self.shutdown_engine())\n        except Exception:\n            pass\n\n\n# Factory functions\n\ndef create_interaction_engine(config: Optional[InteractionEngineConfig] = None,\n                            memory_manager: Optional[Any] = None,\n                            character_manager: Optional[Any] = None,\n                            equipment_manager: Optional[Any] = None) -> InteractionEngine:\n    \"\"\"\n    Factory function to create interaction engine with optimal defaults.\n    \n    Args:\n        config: Optional configuration\n        memory_manager: Optional memory manager\n        character_manager: Optional character manager\n        equipment_manager: Optional equipment manager\n        \n    Returns:\n        Configured InteractionEngine instance\n    \"\"\"\n    if config is None:\n        config = InteractionEngineConfig(\n            max_concurrent_interactions=3,\n            enable_parallel_processing=True,\n            memory_integration_enabled=True,\n            auto_generate_memories=True,\n            performance_monitoring=True,\n            detailed_logging=True\n        )\n    \n    return InteractionEngine(\n        config=config,\n        memory_manager=memory_manager,\n        character_manager=character_manager,\n        equipment_manager=equipment_manager\n    )\n\n\ndef create_performance_optimized_config() -> InteractionEngineConfig:\n    \"\"\"\n    Create performance-optimized configuration.\n    \n    Returns:\n        Performance-optimized InteractionEngineConfig\n    \"\"\"\n    return InteractionEngineConfig(\n        max_concurrent_interactions=5,\n        default_timeout_seconds=180.0,\n        enable_parallel_processing=True,\n        max_queue_size=200,\n        priority_processing=True,\n        auto_queue_cleanup=True,\n        enable_dynamic_templates=True,\n        template_cache_size=100,\n        performance_monitoring=True,\n        detailed_logging=False,  # Reduce logging for performance\n        metrics_collection=True,\n        memory_integration_enabled=True,\n        auto_generate_memories=True,\n        memory_significance_threshold=0.3,  # Lower threshold for more memories\n        content_quality_threshold=0.6,  # Lower threshold for faster processing\n        phase_timeout_seconds=45.0,  # Shorter phase timeouts\n        max_dialogue_exchanges=15  # More dialogue for richer interactions\n    )"