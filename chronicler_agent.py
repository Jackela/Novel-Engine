#!/usr/bin/env python3
"""
ChroniclerAgent Core Implementation
==================================

This module implements the ChroniclerAgent class, which serves as the narrative
transcription system for the StoryForge AI Interactive Story Engine. The ChroniclerAgent
transforms structured campaign logs into dramatic narrative stories that capture
the essence of any fictional universe.
"""

import json
import os
import re
import logging
import time
import random
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass, field
from src.event_bus import EventBus
from src.persona_agent import PersonaAgent
from shared_types import CharacterAction

from config_loader import get_config

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class CampaignEvent:
    """
    Represents a parsed event from the campaign log.
    
    Encapsulates all relevant information needed to generate narrative content
    for a specific event in the simulation timeline.
    """
    turn_number: int
    timestamp: str
    event_type: str
    description: str
    participants: List[str] = field(default_factory=list)
    faction_info: Dict[str, str] = field(default_factory=dict)
    action_details: Dict[str, Any] = field(default_factory=dict)
    raw_text: str = ""


@dataclass
class NarrativeSegment:
    """
    Represents a generated narrative segment for a specific event or turn.
    
    Contains the dramatic prose generated by the LLM along with metadata
    for combining segments into a cohesive story.
    """
    turn_number: int
    event_type: str
    narrative_text: str
    character_focus: List[str] = field(default_factory=list)
    faction_themes: List[str] = field(default_factory=list)
    tone: str = "dramatic"
    timestamp: str = ""


class ChroniclerAgent:
    """
    Core implementation of the narrative transcription system.
    
    The ChroniclerAgent transforms structured campaign logs into dramatic narrative prose.
    """
    
    def __init__(self, event_bus: EventBus, output_directory: Optional[str] = None, max_events_per_batch: Optional[int] = None, narrative_style: Optional[str] = None, character_names: Optional[List[str]] = None):
        """
        Initializes the ChroniclerAgent.

        Args:
            event_bus: An instance of the EventBus for decoupled communication.
            output_directory: Optional path to save generated narratives.
            max_events_per_batch: Optional maximum events per batch.
            narrative_style: Optional narrative style.
            character_names: Optional list of character names for story integration.
        """
        logger.info("Initializing ChroniclerAgent...")
        
        self.event_bus = event_bus
        self.narrative_segments: List[NarrativeSegment] = []

        try:
            config = get_config()
            self._config = config
        except Exception as e:
            logger.warning(f"Failed to load configuration, using defaults: {e}")
            self._config = None
        
        self.output_directory = output_directory or (self._config.chronicler.output_directory if self._config else None)
        self.max_events_per_batch = max_events_per_batch or (self._config.chronicler.max_events_per_batch if self._config else 50)
        self.narrative_style = narrative_style or (self._config.chronicler.narrative_style if self._config else "sci_fi_dramatic")
        self.character_names = character_names or []
        
        self.events_processed = 0
        self.narratives_generated = 0
        self.llm_calls_made = 0
        self.error_count = 0
        self.last_error_time: Optional[datetime] = None
        
        try:
            self._initialize_output_directory()
            self._initialize_narrative_templates()
            self.event_bus.subscribe("AGENT_ACTION_COMPLETE", self.handle_agent_action)
            self.event_bus.subscribe("SIMULATION_END", self.handle_simulation_end)
            logger.info("ChroniclerAgent initialized successfully and subscribed to events.")
        except Exception as e:
            logger.error(f"Failed to initialize ChroniclerAgent: {e}")
            raise ValueError(f"ChroniclerAgent initialization failed: {e}")
    
    def _initialize_output_directory(self) -> None:
        """Initializes and validates the output directory."""
        if not self.output_directory:
            logger.info("No output directory specified; narratives will be returned as strings.")
            return
        
        try:
            output_path = Path(self.output_directory)
            output_path.mkdir(parents=True, exist_ok=True)
            if not output_path.is_dir():
                raise ValueError(f"Output path is not a directory: {self.output_directory}")
            
            # Test write permissions
            (output_path / "test.tmp").touch()
            (output_path / "test.tmp").unlink()
            logger.info(f"Output directory validated: {self.output_directory}")
        except Exception as e:
            raise OSError(f"Output directory initialization failed: {e}")
    
    def _initialize_narrative_templates(self) -> None:
        """Initializes narrative generation templates."""
        self.narrative_templates = {
            'opening': "In the vast expanse of the cosmos, a story unfolds.",
            'agent_registration': "{character_name} of the {faction} has joined the conflict.",
            'character_action': "{character_name} chose to {action_type}. {action_description}",
            'turn_summary': "As turn {turn_number} concludes, the situation is as follows: {summary_text}",
            'closing': "Thus concludes this chapter of the saga."
        }
        self.faction_descriptions = {'Unknown': 'warriors of unclear allegiance'}
        logger.info("Narrative templates initialized.")
    
    def handle_agent_action(self, agent: PersonaAgent, action: Optional[CharacterAction]):
        """Handles the AGENT_ACTION_COMPLETE event."""
        if not action:
            return

        character_name = agent.character_data.get('name', 'Unknown')
        description = f"{character_name} decided to {action.action_type}"
        if action.reasoning:
            description += f": {action.reasoning}"

        event = CampaignEvent(
            turn_number=0, # This will need to be passed in the event payload
            timestamp=datetime.now().isoformat(),
            event_type='character_action',
            description=description
        )
        narrative_text = self._generate_event_narrative(event)
        if narrative_text:
            self.narrative_segments.append(NarrativeSegment(
                turn_number=event.turn_number,
                event_type=event.event_type,
                narrative_text=narrative_text
            ))

    def handle_simulation_end(self):
        """Handles the SIMULATION_END event, finalizing the narrative."""
        logger.info("Simulation ended, generating final narrative.")
        complete_story = self._combine_narrative_segments(self.narrative_segments)
        if self.output_directory:
            self._save_narrative_to_file(complete_story, "simulation_narrative")

    def _generate_event_narrative(self, event: CampaignEvent) -> str:
        """Generates narrative prose for a single event."""
        prompt = self._create_narrative_prompt(event)
        return self._call_llm(prompt)

    def _create_narrative_prompt(self, event: CampaignEvent) -> str:
        """Creates a contextual prompt for LLM narrative generation."""
        return f"Narrate this event dramatically: {event.description}"

    def _call_llm(self, prompt: str) -> str:
        """Makes an LLM API call for narrative generation."""
        logger.debug(f"ChroniclerAgent calling LLM with prompt: {prompt}")
        time.sleep(0.1) # Simulate API call
        self.llm_calls_made += 1
        # Fallback for now
        return f"A noteworthy event occurred: {prompt.split(':')[-1].strip()}"

    def _combine_narrative_segments(self, segments: List[NarrativeSegment]) -> str:
        """Combines individual narrative segments into a cohesive story."""
        if not segments: 
            return "No significant events to narrate."
        
        story = self.narrative_templates['opening'] + "\n\n"
        story += "\n\n".join([s.narrative_text for s in sorted(segments, key=lambda x: x.turn_number)])
        story += "\n\n" + self.narrative_templates['closing']
        return story

    def _save_narrative_to_file(self, narrative: str, base_filename: str) -> str:
        """Saves the generated narrative to a file."""
        filename = f"{base_filename}_narrative_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        output_path = Path(self.output_directory) / filename
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(f"# Narrative for {base_filename}\n\n{narrative}")
        
        logger.info(f"Narrative saved to: {output_path}")
        return str(output_path)

    def transcribe_log(self, campaign_log_path: str) -> str:
        """
        Transcribes a campaign log file into a narrative story.
        
        This method provides backward compatibility with the API server by reading
        a campaign log file and converting it into a narrative story using the
        ChroniclerAgent's narrative generation capabilities.
        
        Args:
            campaign_log_path: Path to the campaign log file to transcribe
            
        Returns:
            str: The generated narrative story
            
        Raises:
            FileNotFoundError: If the campaign log file doesn't exist
            Exception: If narrative generation fails
        """
        try:
            # Read the campaign log file
            if not os.path.exists(campaign_log_path):
                raise FileNotFoundError(f"Campaign log file not found: {campaign_log_path}")
            
            with open(campaign_log_path, 'r', encoding='utf-8') as f:
                log_content = f.read()
            
            # Parse the log content into events
            events = self._parse_campaign_log(log_content)
            
            # Generate narrative segments for each event
            narrative_segments = []
            for event in events:
                narrative_text = self._generate_event_narrative(event)
                if narrative_text:
                    narrative_segments.append(NarrativeSegment(
                        turn_number=event.turn_number,
                        event_type=event.event_type,
                        narrative_text=narrative_text
                    ))
            
            # Combine all segments into a complete story
            complete_story = self._combine_narrative_segments(narrative_segments)
            
            logger.info(f"Transcribed campaign log {campaign_log_path} into {len(complete_story)} character story")
            return complete_story
            
        except Exception as e:
            logger.error(f"Failed to transcribe campaign log {campaign_log_path}: {e}")
            # Return a basic story if transcription fails
            return f"A tale unfolds from the campaign records, though the details remain shrouded in mystery. {len(self.character_names)} brave souls participated in this adventure."

    def _parse_campaign_log(self, log_content: str) -> List[CampaignEvent]:
        """
        Parses campaign log content into structured events.
        
        Args:
            log_content: Raw content of the campaign log file
            
        Returns:
            List[CampaignEvent]: Parsed events from the log
        """
        events = []
        turn_number = 0
        
        # Split content into lines and process
        lines = log_content.split('\n')
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            # Look for turn markers
            if '=== STARTING TURN' in line.upper() or 'TURN' in line.upper() and 'BEGINS' in line.upper():
                turn_number += 1
                events.append(CampaignEvent(
                    turn_number=turn_number,
                    timestamp=datetime.now().isoformat(),
                    event_type='turn_start',
                    description=f"Turn {turn_number} begins",
                    raw_text=line
                ))
                continue
            
            # Look for agent actions
            if 'decided to' in line.lower() or 'chose to' in line.lower():
                # Extract character name and action
                participants = []
                action_description = line
                
                # Try to extract character names
                for char_name in self.character_names:
                    if char_name.lower() in line.lower():
                        participants.append(char_name)
                
                events.append(CampaignEvent(
                    turn_number=turn_number,
                    timestamp=datetime.now().isoformat(),
                    event_type='character_action',
                    description=action_description,
                    participants=participants,
                    raw_text=line
                ))
                continue
            
            # Look for agent registration
            if 'joined' in line.lower() or 'registration' in line.lower():
                participants = []
                for char_name in self.character_names:
                    if char_name.lower() in line.lower():
                        participants.append(char_name)
                
                events.append(CampaignEvent(
                    turn_number=0,
                    timestamp=datetime.now().isoformat(),
                    event_type='agent_registration',
                    description=line,
                    participants=participants,
                    raw_text=line
                ))
        
        logger.info(f"Parsed {len(events)} events from campaign log")
        return events

def example_usage():
    """Example usage of the ChroniclerAgent class."""
    print("ChroniclerAgent class is ready for use.")

if __name__ == "__main__":
    example_usage()