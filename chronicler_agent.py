#!/usr/bin/env python3
"""
ChroniclerAgent Core Implementation
==================================

This module implements the ChroniclerAgent class, which serves as the narrative
transcription system for the Warhammer 40k Multi-Agent Simulator. The ChroniclerAgent
transforms structured campaign logs into dramatic narrative stories that capture
the essence of the grimdark universe.

The ChroniclerAgent acts as the story chronicler that:
1. Parses structured campaign logs from DirectorAgent
2. Extracts key events, character actions, and faction dynamics
3. Uses LLM integration to generate dramatic narrative prose
4. Combines individual event narratives into cohesive stories
5. Maintains the authentic Warhammer 40k atmosphere and tone

This implementation provides the Phase 4 story transcription capability that transforms
raw simulation data into compelling narrative content for players and readers.

Architecture Reference: Architecture_Blueprint.md Section 2.4 ChroniclerAgent
Development Phase: Phase 4 - Story Transcription (Final Integration)
"""

import json
import os
import re
import logging
import time
import random
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass, field

# 引入配置系统圣典，获取史官代理的神圣参数...
from config_loader import get_config

# 配置史官操作追踪的记录仪式，监控叙事生成的每个神圣步骤...
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class CampaignEvent:
    """
    Represents a parsed event from the campaign log.
    
    Encapsulates all relevant information needed to generate narrative content
    for a specific event in the simulation timeline.
    """
    turn_number: int
    timestamp: str
    event_type: str  # e.g., "agent_registration", "turn_begin", "action", "turn_end"
    description: str
    participants: List[str] = field(default_factory=list)
    faction_info: Dict[str, str] = field(default_factory=dict)
    action_details: Dict[str, Any] = field(default_factory=dict)
    raw_text: str = ""


@dataclass
class NarrativeSegment:
    """
    Represents a generated narrative segment for a specific event or turn.
    
    Contains the dramatic prose generated by the LLM along with metadata
    for combining segments into a cohesive story.
    """
    turn_number: int
    event_type: str
    narrative_text: str
    character_focus: List[str] = field(default_factory=list)
    faction_themes: List[str] = field(default_factory=list)
    tone: str = "dramatic"  # dramatic, tactical, philosophical, etc.
    timestamp: str = ""


class ChroniclerAgent:
    """
    Core implementation of the narrative transcription system for the Warhammer 40k Multi-Agent Simulator.
    
    The ChroniclerAgent serves as the story chronicler that transforms structured campaign logs
    into dramatic narrative prose. It maintains the authentic grimdark atmosphere while creating
    engaging stories that capture the essence of character interactions and faction dynamics.
    
    Key Responsibilities:
    - Campaign log parsing and event extraction
    - LLM-powered narrative generation for individual events
    - Story combination and flow management
    - Warhammer 40k atmosphere and tone preservation
    - Error handling and graceful degradation for malformed logs
    
    Architecture Notes:
    - Designed for integration with existing campaign log format from DirectorAgent
    - Uses the same LLM placeholder pattern as PersonaAgent for future API integration
    - Maintains modular design for easy extension and customization
    - Provides comprehensive logging for debugging and performance monitoring
    - Supports batch processing of multiple campaign logs
    """
    
    def __init__(self, output_directory: Optional[str] = None, max_events_per_batch: Optional[int] = None, narrative_style: Optional[str] = None):
        """
        Initialize the ChroniclerAgent with narrative generation capabilities.
        
        Sets up the core chronicler infrastructure including log parsing systems,
        narrative generation templates, and output management.
        
        Args:
            output_directory: Optional path to directory for saving generated narratives
                            If provided, narratives will be saved to files
                            If None, uses configuration or returns strings only
            max_events_per_batch: Optional maximum events per batch
                                If None, uses configuration value
            narrative_style: Optional narrative style
                           If None, uses configuration value
                            
        Raises:
            ValueError: If output_directory is provided but is not a valid directory
            OSError: If directory operations fail due to permissions or disk issues
        """
        logger.info("Initializing ChroniclerAgent - Narrative Transcription System starting up")
        
        # 加载配置圣典，获取史官代理的神圣指令...
        try:
            config = get_config()
            self._config = config
        except Exception as e:
            logger.warning(f"Failed to load configuration, using defaults: {e}")
            self._config = None
        
        # 核心史官配置圣礼 - 如果可用则使用配置数值，遵循机械教条...
        if output_directory is None and self._config:
            output_directory = self._config.chronicler.output_directory
        self.output_directory = output_directory
        """Directory path for saving generated narrative files"""
        
        # 叙事生成设定圣典 - 如果可用则使用配置数值，保证圣言的统一...
        if max_events_per_batch is None:
            if self._config:
                max_events_per_batch = self._config.chronicler.max_events_per_batch
            else:
                max_events_per_batch = 50
        self.max_events_per_batch = max_events_per_batch
        """Maximum number of events to process in a single batch"""
        
        if narrative_style is None:
            if self._config:
                narrative_style = self._config.chronicler.narrative_style
            else:
                narrative_style = "grimdark_dramatic"
        self.narrative_style = narrative_style
        """Narrative style for story generation"""
        
        # 事件处理追踪在，记录史官代理对每个战役事件的处理进度...
        self.events_processed = 0
        """Counter for total events processed"""
        
        self.narratives_generated = 0
        """Counter for narrative segments generated"""
        
        self.llm_calls_made = 0
        """Counter for LLM API calls made"""
        
        # 错误追踪监控仪，监控史官机器灵魂的稳定性...
        self.error_count = 0
        """Count of errors encountered during processing"""
        
        self.last_error_time: Optional[datetime] = None
        """Timestamp of the most recent error"""
        
        # 初始化史官系统，唤醒叙事生成引擎的机械灵魂...
        try:
            self._initialize_output_directory()
            self._initialize_narrative_templates()
            
            logger.info(f"ChroniclerAgent initialized successfully")
            logger.info(f"Output directory: {self.output_directory or 'None (return strings only)'}")
            logger.info(f"Narrative style: {self.narrative_style}")
            logger.info(f"Max events per batch: {self.max_events_per_batch}")
            
        except Exception as e:
            logger.error(f"Failed to initialize ChroniclerAgent: {str(e)}")
            raise ValueError(f"ChroniclerAgent initialization failed: {str(e)}")
    
    def _initialize_output_directory(self) -> None:
        """
        Initialize and validate the output directory for narrative files.
        
        Creates the directory if it doesn't exist and validates write permissions.
        
        Raises:
            ValueError: If output_directory path is invalid
            OSError: If directory creation or validation fails
        """
        if self.output_directory is None:
            logger.info("No output directory specified, narratives will be returned as strings only")
            return
        
        try:
            # 转换为路径对象，便于进行文件系统的神圣操作...
            output_path = Path(self.output_directory)
            
            # 如果目录不存在则创建，建立叙事输出的神圣圣域...
            if not output_path.exists():
                output_path.mkdir(parents=True, exist_ok=True)
                logger.info(f"Created output directory: {self.output_directory}")
            
            # 验证路径确为目录，确保文件系统结构的神圣正确性...
            if not output_path.is_dir():
                raise ValueError(f"Output path exists but is not a directory: {self.output_directory}")
            
            # 测试写入权限，验证史官代理是否能在此圣域书写传说...
            test_file = output_path / "test_write_permission.tmp"
            try:
                test_file.touch()
                test_file.unlink()
                logger.info(f"Output directory validated with write permissions: {self.output_directory}")
            except Exception as e:
                raise OSError(f"No write permissions for output directory: {self.output_directory}")
                
        except Exception as e:
            logger.error(f"Failed to initialize output directory: {str(e)}")
            raise OSError(f"Output directory initialization failed: {str(e)}")
    
    def _initialize_narrative_templates(self) -> None:
        """
        Initialize narrative generation templates and style configurations.
        
        Sets up the templates used for generating different types of narrative content
        based on event types and faction contexts.
        """
        self.narrative_templates = {
            'opening': {
                'grimdark_dramatic': (
                    "In the grim darkness of the far future, where there is only war, "
                    "the chronicles of {location} unfold with terrible purpose. "
                    "The Emperor's light flickers dimly against the encroaching shadows, "
                    "and heroes and villains alike dance to the whims of fate."
                ),
                'tactical': (
                    "Strategic Analysis: Campaign Log {campaign_id}\n"
                    "Location: {location}\n"
                    "The following events transpired during the recorded engagement."
                ),
                'philosophical': (
                    "What is the nature of war in a universe where peace is but a fleeting dream? "
                    "These chronicles attempt to capture the essence of conflict that defines "
                    "the existence of all who dwell in the Emperor's domain."
                )
            },
            'agent_registration': {
                'grimdark_dramatic': (
                    "As the shadows lengthened across the battlefield, {character_name} "
                    "emerged from the {faction} ranks. {character_description} "
                    "Their arrival would prove to be a turning point in the conflicts to come."
                ),
                'tactical': (
                    "Unit Deployment: {character_name} ({faction})\n"
                    "Status: Operational\n"
                    "Mission Parameters: Engaged"
                ),
            },
            'character_action': {
                'grimdark_dramatic': (
                    "{character_name}, driven by {motivation}, chose to {action_type}. "
                    "{action_description} The consequences of this decision would "
                    "ripple through the fabric of the conflict itself."
                ),
                'tactical': (
                    "Action Report: {character_name}\n"
                    "Action Type: {action_type}\n"
                    "Tactical Assessment: {action_description}"
                ),
            },
            'turn_summary': {
                'grimdark_dramatic': (
                    "As the dust settled on Turn {turn_number}, the weight of decisions "
                    "made and actions taken hung heavy in the air. {summary_text} "
                    "The war machine ground onward, ever hungry for more sacrifice."
                ),
                'tactical': (
                    "Turn {turn_number} Summary:\n"
                    "{summary_text}\n"
                    "Tactical Status: Continuing operations"
                ),
            },
            'closing': {
                'grimdark_dramatic': (
                    "Thus concludes this chapter in the endless war that defines existence "
                    "in the 41st millennium. The heroes and villains of this tale have "
                    "played their parts in the grand tragedy that is humanity's struggle "
                    "for survival. In the grim darkness of the far future, there is only war... "
                    "and the echoes of those who dared to defy the darkness."
                ),
                'tactical': (
                    "End of Mission Report\n"
                    "All recorded events processed\n"
                    "Archive Status: Complete"
                ),
            }
        }
        
        self.faction_descriptions = {
            'Space Marines': 'the Emperor\'s finest warriors, clad in ceramite and faith',
            'Imperial Guard': 'the stalwart defenders of humanity, armed with courage and lasgun',
            'Astra Militarum': 'the infinite ranks of the Emperor\'s hammer',
            'Death Korps of Krieg': 'the gas-masked harbingers of industrial warfare',
            'Adeptus Mechanicus': 'the tech-priests who seek truth in the machine',
            'Orks': 'the green tide of destruction that knows only WAAAGH!',
            'Goff Klan': 'the brutal elite of the ork war machine',
            'Chaos': 'the corrupted servants of the Ruinous Powers',
            'Imperial': 'servants of the Golden Throne',
            'Unknown': 'warriors of unclear allegiance'
        }
        
        logger.info("Narrative templates initialized for Warhammer 40k atmosphere")
    
    def transcribe_log(self, log_path: str) -> str:
        """
        Transform a structured campaign log into a dramatic narrative story.
        
        This is the main method that orchestrates the entire transcription process:
        1. Parse the campaign log file to extract structured events
        2. Generate narrative segments for each significant event using LLM calls
        3. Combine individual narratives into a cohesive story
        4. Apply final formatting and atmospheric touches
        5. Optionally save the result to a file
        
        Args:
            log_path: Path to the campaign log markdown file to transcribe
                     Must be a valid file path to a DirectorAgent-generated log
                     
        Returns:
            str: Complete narrative story as a single string
                Contains dramatic prose capturing the essence of the campaign
                
        Raises:
            FileNotFoundError: If log_path does not exist or is not accessible
            ValueError: If log file is malformed or cannot be parsed
            OSError: If file reading operations fail
            
        Example:
            >>> chronicler = ChroniclerAgent()
            >>> story = chronicler.transcribe_log("campaign_log.md")
            >>> print(story[:100])  # First 100 characters of the generated story
        """
        start_time = datetime.now()
        logger.info(f"Starting campaign log transcription: {log_path}")
        
        try:
            # 验证输入文件，确保战役日志的完整性与可读性...
            if not os.path.exists(log_path):
                raise FileNotFoundError(f"Campaign log file not found: {log_path}")
            
            if not os.path.isfile(log_path):
                raise ValueError(f"Path is not a file: {log_path}")
            
            # 第一步神圣仪式：解析战役日志，提取英雄事迹的原始数据...
            logger.info("Parsing campaign log for events...")
            parsed_events = self._parse_campaign_log(log_path)
            
            if not parsed_events:
                logger.warning("No events found in campaign log")
                return self._generate_empty_narrative(log_path)
            
            logger.info(f"Parsed {len(parsed_events)} events from campaign log")
            
            # 第二步神圣仪式：为事件生成叙事片段，将战术数据转化为传说...
            logger.info("Generating narrative segments using LLM...")
            narrative_segments = self._generate_narrative_segments(parsed_events)
            
            logger.info(f"Generated {len(narrative_segments)} narrative segments")
            
            # 第三步神圣仪式：将片段组合成连贯故事，编织完整的英雄史诗...
            logger.info("Combining narrative segments into cohesive story...")
            complete_story = self._combine_narrative_segments(narrative_segments, log_path)
            
            # 第四步神圣仪式：应用最终格式化并保存（如果被请求），完成传说的最终形态...
            if self.output_directory:
                output_file = self._save_narrative_to_file(complete_story, log_path)
                logger.info(f"Narrative saved to: {output_file}")
            
            # 计算处理指标，衡量史官代理的工作效率与质量...
            end_time = datetime.now()
            processing_duration = (end_time - start_time).total_seconds()
            
            logger.info(f"Campaign transcription completed successfully")
            logger.info(f"Processing time: {processing_duration:.2f} seconds")
            logger.info(f"Events processed: {len(parsed_events)}")
            logger.info(f"Narrative segments: {len(narrative_segments)}")
            logger.info(f"LLM calls made: {self.llm_calls_made}")
            logger.info(f"Final story length: {len(complete_story)} characters")
            
            return complete_story
            
        except Exception as e:
            logger.error(f"Failed to transcribe campaign log: {str(e)}")
            self.error_count += 1
            self.last_error_time = datetime.now()
            
            # 对于关键错误重新抛出；对于轻微问题返回部分结果，机器灵魂的智慧处理...
            if isinstance(e, (FileNotFoundError, ValueError, OSError)):
                raise e
            else:
                logger.warning("Attempting to generate partial narrative due to processing error")
                return self._generate_error_narrative(log_path, str(e))
    
    def _parse_campaign_log(self, log_path: str) -> List[CampaignEvent]:
        """
        Parse a campaign log file and extract structured event data.
        
        Reads the markdown-formatted campaign log and extracts individual events
        with their metadata, timestamps, and participant information.
        
        Args:
            log_path: Path to the campaign log file
            
        Returns:
            List of CampaignEvent objects representing parsed events
            
        Raises:
            OSError: If file reading fails
            ValueError: If log format is severely malformed
        """
        try:
            with open(log_path, 'r', encoding='utf-8') as file:
                content = file.read()
            
            events = []
            current_turn = 0
            
            # 按回合事件分割内容，解析战役的结构化数据...
            event_sections = re.split(r'### Turn \d+ Event', content)
            
            for section in event_sections[1:]:  # Skip the header section
                try:
                    event = self._parse_event_section(section, current_turn)
                    if event:
                        events.append(event)
                        # Update turn number if this event indicates a new turn
                        if event.event_type in ['turn_begin', 'turn_end']:
                            current_turn = event.turn_number
                        self.events_processed += 1
                        
                except Exception as e:
                    logger.warning(f"Failed to parse event section: {str(e)}")
                    continue
            
            logger.info(f"Successfully parsed {len(events)} events from campaign log")
            return events
            
        except Exception as e:
            logger.error(f"Failed to read campaign log file: {str(e)}")
            raise OSError(f"Campaign log parsing failed: {str(e)}")
    
    def _parse_event_section(self, section: str, current_turn: int) -> Optional[CampaignEvent]:
        """
        Parse an individual event section from the campaign log.
        
        Extracts timestamp, event description, and participant information
        from a single event entry in the markdown log.
        
        Args:
            section: Raw text of the event section
            current_turn: Current turn number for context
            
        Returns:
            CampaignEvent object or None if parsing fails
        """
        try:
            lines = section.strip().split('\n')
            if not lines:
                return None
            
            # Initialize event data
            timestamp = ""
            event_description = ""
            turn_number = current_turn
            participants = []
            faction_info = {}
            action_details = {}
            
            # Parse each line for relevant information
            for line in lines:
                line = line.strip()
                
                if line.startswith('**Time:**'):
                    timestamp = line.replace('**Time:**', '').strip()
                
                elif line.startswith('**Event:**'):
                    event_description = line.replace('**Event:**', '').strip()
                
                elif line.startswith('**Turn:**'):
                    try:
                        turn_number = int(line.replace('**Turn:**', '').strip())
                    except ValueError:
                        pass
            
            if not event_description:
                return None
            
            # Determine event type and extract additional details
            event_type = self._classify_event_type(event_description)
            
            # Extract participant and faction information
            participants, faction_info = self._extract_participant_info(event_description)
            
            # Extract action details for character actions
            if event_type == 'character_action':
                action_details = self._extract_action_details(event_description)
            
            return CampaignEvent(
                turn_number=turn_number,
                timestamp=timestamp,
                event_type=event_type,
                description=event_description,
                participants=participants,
                faction_info=faction_info,
                action_details=action_details,
                raw_text=section
            )
            
        except Exception as e:
            logger.debug(f"Error parsing event section: {str(e)}")
            return None
    
    def _classify_event_type(self, description: str) -> str:
        """
        Classify an event based on its description text.
        
        Args:
            description: Event description text
            
        Returns:
            Event type classification string
        """
        description_lower = description.lower()
        
        if 'agent registration' in description_lower or 'joined the simulation' in description_lower:
            return 'agent_registration'
        elif 'turn' in description_lower and 'begins' in description_lower:
            return 'turn_begin'
        elif 'turn' in description_lower and 'completed' in description_lower:
            return 'turn_end'
        elif any(action in description_lower for action in ['decided to', 'chose to', 'action:']):
            return 'character_action'
        elif 'error' in description_lower:
            return 'error_event'
        elif 'initialization' in description_lower or 'started' in description_lower:
            return 'initialization'
        else:
            return 'general_event'
    
    def _extract_participant_info(self, description: str) -> Tuple[List[str], Dict[str, str]]:
        """
        Extract participant names and faction information from event description.
        
        Args:
            description: Event description text
            
        Returns:
            Tuple of (participant_names, faction_info)
        """
        participants = []
        faction_info = {}
        
        # Pattern for character names in parentheses
        character_pattern = r'(\w+(?:\s+\w+)*)\s*\(([^)]+)\)'
        matches = re.findall(character_pattern, description)
        
        for character_name, agent_id in matches:
            participants.append(character_name)
            
        # Pattern for faction information
        faction_pattern = r'\*\*Faction:\*\*\s*([^\\]+)'
        faction_match = re.search(faction_pattern, description)
        
        if faction_match:
            faction_text = faction_match.group(1).strip()
            if participants:
                faction_info[participants[-1]] = faction_text
        
        return participants, faction_info
    
    def _extract_action_details(self, description: str) -> Dict[str, Any]:
        """
        Extract action-specific details from character action descriptions.
        
        Args:
            description: Event description text
            
        Returns:
            Dictionary of action details
        """
        action_details = {}
        
        # Extract action type
        action_patterns = [
            r'decided to (\w+)',
            r'chose to (\w+)',
            r'action:\s*(\w+)'
        ]
        
        for pattern in action_patterns:
            match = re.search(pattern, description, re.IGNORECASE)
            if match:
                action_details['action_type'] = match.group(1)
                break
        
        # Extract reasoning if present
        reasoning_pattern = r':\s*\[LLM-Guided\]\s*([^.]+\.?)'
        reasoning_match = re.search(reasoning_pattern, description)
        
        if reasoning_match:
            action_details['reasoning'] = reasoning_match.group(1).strip()
        
        return action_details
    
    def _generate_narrative_segments(self, events: List[CampaignEvent]) -> List[NarrativeSegment]:
        """
        Generate narrative segments for a list of campaign events using LLM calls.
        
        Processes events in batches and generates dramatic prose for each significant event
        that contributes to the overall story narrative.
        
        Args:
            events: List of parsed campaign events
            
        Returns:
            List of generated narrative segments
        """
        narrative_segments = []
        
        # Filter events that should be included in the narrative
        significant_events = self._filter_significant_events(events)
        
        logger.info(f"Processing {len(significant_events)} significant events for narrative generation")
        
        for event in significant_events:
            try:
                # Generate narrative for this event
                narrative_text = self._generate_event_narrative(event)
                
                if narrative_text:
                    segment = NarrativeSegment(
                        turn_number=event.turn_number,
                        event_type=event.event_type,
                        narrative_text=narrative_text,
                        character_focus=event.participants,
                        faction_themes=list(event.faction_info.values()),
                        tone=self.narrative_style,
                        timestamp=event.timestamp
                    )
                    
                    narrative_segments.append(segment)
                    self.narratives_generated += 1
                    
                    logger.debug(f"Generated narrative for {event.event_type} event: {len(narrative_text)} characters")
                
            except Exception as e:
                logger.warning(f"Failed to generate narrative for event: {str(e)}")
                continue
        
        return narrative_segments
    
    def _filter_significant_events(self, events: List[CampaignEvent]) -> List[CampaignEvent]:
        """
        Filter events to include only those significant for narrative purposes.
        
        Args:
            events: All parsed events
            
        Returns:
            Filtered list of significant events
        """
        significant_types = {
            'agent_registration', 'character_action', 'turn_begin', 
            'turn_end', 'initialization', 'error_event'
        }
        
        return [event for event in events if event.event_type in significant_types]
    
    def _generate_event_narrative(self, event: CampaignEvent) -> str:
        """
        Generate narrative prose for a single event using LLM integration.
        
        Creates a contextual prompt for the event and calls the LLM to generate
        dramatic narrative content in the Warhammer 40k style.
        
        Args:
            event: Campaign event to generate narrative for
            
        Returns:
            Generated narrative text
        """
        try:
            # Create contextual prompt for the LLM
            prompt = self._create_narrative_prompt(event)
            
            # Call LLM for narrative generation
            llm_response = self._call_llm(prompt)
            
            # Post-process the LLM response
            narrative_text = self._post_process_narrative(llm_response, event)
            
            return narrative_text
            
        except Exception as e:
            logger.warning(f"LLM narrative generation failed for event: {str(e)}")
            return self._generate_fallback_narrative(event)
    
    def _create_narrative_prompt(self, event: CampaignEvent) -> str:
        """
        Create a contextual prompt for LLM narrative generation.
        
        Args:
            event: Campaign event to create prompt for
            
        Returns:
            Formatted prompt string for the LLM
        """
        # Base prompt template
        base_prompt = (
            "You are a Warhammer 40k historian chronicling the events of a great campaign. "
            "Write a dramatic, atmospheric narrative describing the following event in the "
            "grimdark style of the 41st millennium. Use vivid imagery, appropriate faction "
            "terminology, and maintain the dark, epic tone of Warhammer 40k.\n\n"
        )
        
        # Add event context
        context = f"Event Type: {event.event_type}\n"
        context += f"Turn: {event.turn_number}\n"
        context += f"Timestamp: {event.timestamp}\n"
        
        if event.participants:
            context += f"Characters Involved: {', '.join(event.participants)}\n"
        
        if event.faction_info:
            context += "Faction Information:\n"
            for char, faction in event.faction_info.items():
                context += f"  - {char}: {faction}\n"
        
        if event.action_details:
            context += f"Action Details: {event.action_details}\n"
        
        context += f"\nEvent Description: {event.description}\n\n"
        
        # Add style guidance
        style_guidance = (
            "Generate 2-3 sentences of dramatic narrative that captures the essence "
            "of this event. Focus on atmosphere, character motivation, and the weight "
            "of consequences in the grim darkness of the far future. Use faction-appropriate "
            "language and imagery."
        )
        
        return base_prompt + context + style_guidance
    
    def _call_llm(self, prompt: str) -> str:
        """
        Make an LLM API call for narrative generation.
        
        This function follows the same pattern as PersonaAgent's _call_llm method
        and serves as the integration point for future LLM API connections.
        
        Args:
            prompt: Formatted prompt string for the LLM
            
        Returns:
            String response from the LLM (or simulated response for testing)
            
        Raises:
            Exception: If LLM API call fails
        """
        logger.debug(f"ChroniclerAgent calling LLM with prompt length: {len(prompt)} characters")
        
        # Simulate API call delay
        time.sleep(0.1)
        
        # Track LLM calls
        self.llm_calls_made += 1
        
        # For Phase 4 implementation, return simulated dramatic responses
        # In actual deployment, this would connect to GPT, Claude, or another LLM service
        
        # Simulate realistic LLM response delay
        time.sleep(0.2)
        
        # Generate contextually appropriate response based on prompt content
        if "agent registration" in prompt.lower() or "joined the simulation" in prompt.lower():
            return self._generate_registration_response(prompt)
        elif "decided to" in prompt.lower() or "action" in prompt.lower():
            return self._generate_action_response(prompt)
        elif "turn" in prompt.lower() and "begins" in prompt.lower():
            return self._generate_turn_begin_response(prompt)
        elif "turn" in prompt.lower() and "completed" in prompt.lower():
            return self._generate_turn_end_response(prompt)
        else:
            return self._generate_general_response(prompt)
    
    def _generate_registration_response(self, prompt: str) -> str:
        """Generate a simulated LLM response for agent registration events."""
        responses = [
            "From the shadowed ranks emerged a new warrior, their presence marking another soul bound to the eternal conflict that defines the 41st millennium.",
            "The muster rolls swelled with another name, another life pledged to the Emperor's service in humanity's darkest hour.",
            "With the thunder of marching boots and the weight of duty, a new combatant joined the ranks of those who would shape the destiny of worlds.",
        ]
        return random.choice(responses)
    
    def _generate_action_response(self, prompt: str) -> str:
        """Generate a simulated LLM response for character action events."""
        responses = [
            "In the crucible of decision, where hesitation meant death and action meant consequence, the warrior chose their path through the darkness.",
            "The weight of choice pressed down like the gravity of a dying star, yet still they moved forward, driven by purpose and the harsh necessities of war.",
            "With the certainty of the righteous and the desperation of the damned, they committed to their course, knowing that in the grim darkness of the far future, there is only war.",
        ]
        return random.choice(responses)
    
    def _generate_turn_begin_response(self, prompt: str) -> str:
        """Generate a simulated LLM response for turn beginning events."""
        responses = [
            "Time itself seemed to hold its breath as new possibilities crystallized from the chaos of war, each moment pregnant with the potential for glory or damnation.",
            "The great wheel of fate turned once more, grinding forward with the inexorable momentum of destiny itself.",
            "As the shadows lengthened and the Emperor's light grew dim, another chapter in the endless war began to unfold.",
        ]
        return random.choice(responses)
    
    def _generate_turn_end_response(self, prompt: str) -> str:
        """Generate a simulated LLM response for turn ending events."""
        responses = [
            "The echoes of action faded into the eternal silence that follows decision, leaving only consequences to mark the passage of time.",
            "With the finality of a blade's edge, the moment passed into history, its weight measured not in time but in the price of souls.",
            "The chapter closed with the weight of finality, yet the war continued, as it always had, as it always would.",
        ]
        return random.choice(responses)
    
    def _generate_general_response(self, prompt: str) -> str:
        """Generate a simulated LLM response for general events."""
        responses = [
            "In the grinding machinery of war, even the smallest events carried the weight of destiny upon their shoulders.",
            "The tapestry of conflict wove itself tighter, each thread a life, each pattern a moment that would echo through eternity.",
            "Within the vast scope of galactic warfare, individual moments crystallized into something approaching meaning.",
        ]
        return random.choice(responses)
    
    def _post_process_narrative(self, llm_response: str, event: CampaignEvent) -> str:
        """
        Post-process the LLM response to ensure quality and consistency.
        
        Args:
            llm_response: Raw response from the LLM
            event: Original event for context
            
        Returns:
            Cleaned and formatted narrative text
        """
        # Clean up the response
        narrative = llm_response.strip()
        
        # Ensure proper sentence structure
        if not narrative.endswith(('.', '!', '?')):
            narrative += '.'
        
        # Add character names if they were involved but not mentioned
        if event.participants and not any(name.lower() in narrative.lower() for name in event.participants):
            # Prepend character context if needed
            if len(event.participants) == 1:
                char_name = event.participants[0]
                narrative = f"For {char_name}, " + narrative.lower()
        
        return narrative
    
    def _generate_fallback_narrative(self, event: CampaignEvent) -> str:
        """
        Generate a fallback narrative when LLM processing fails.
        
        Args:
            event: Campaign event to generate fallback for
            
        Returns:
            Basic narrative text based on templates
        """
        try:
            template_key = event.event_type
            style_key = 'grimdark_dramatic'
            
            if template_key in self.narrative_templates and style_key in self.narrative_templates[template_key]:
                template = self.narrative_templates[template_key][style_key]
                
                # Fill in template variables
                format_vars = {
                    'character_name': event.participants[0] if event.participants else 'A warrior',
                    'faction': list(event.faction_info.values())[0] if event.faction_info else 'unknown forces',
                    'action_type': event.action_details.get('action_type', 'act'),
                    'turn_number': event.turn_number,
                    'action_description': event.action_details.get('reasoning', 'with purpose unknown'),
                    'character_description': self._get_faction_description(event.faction_info),
                    'motivation': 'duty and honor',
                }
                
                return template.format(**format_vars)
            
        except Exception as e:
            logger.debug(f"Fallback narrative generation failed: {str(e)}")
        
        # Ultimate fallback
        return f"In the darkness of the 41st millennium, events transpired that would echo through eternity."
    
    def _get_faction_description(self, faction_info: Dict[str, str]) -> str:
        """
        Get atmospheric description for a faction.
        
        Args:
            faction_info: Dictionary mapping characters to factions
            
        Returns:
            Atmospheric faction description
        """
        if not faction_info:
            return "A warrior of unknown allegiance"
        
        faction = list(faction_info.values())[0]
        
        for faction_key, description in self.faction_descriptions.items():
            if faction_key.lower() in faction.lower():
                return description
        
        return "a servant of the Emperor's will"
    
    def _combine_narrative_segments(self, segments: List[NarrativeSegment], log_path: str) -> str:
        """
        Combine individual narrative segments into a cohesive story.
        
        Organizes segments chronologically and adds transitions, opening,
        and closing sections to create a complete narrative.
        
        Args:
            segments: List of narrative segments to combine
            log_path: Original log file path for context
            
        Returns:
            Complete narrative story as a single string
        """
        if not segments:
            return self._generate_empty_narrative(log_path)
        
        # Sort segments by turn number and event type
        sorted_segments = sorted(segments, key=lambda s: (s.turn_number, self._get_event_order(s.event_type)))
        
        # Build the complete story
        story_parts = []
        
        # Add opening section
        story_parts.append(self._generate_story_opening(sorted_segments, log_path))
        story_parts.append("\n\n")
        
        # Add narrative segments with appropriate transitions
        current_turn = -1
        for i, segment in enumerate(sorted_segments):
            # Add turn transition if needed
            if segment.turn_number != current_turn:
                if current_turn > -1:  # Not the first turn
                    story_parts.append("\n\n")
                current_turn = segment.turn_number
            
            # Add the narrative segment
            story_parts.append(segment.narrative_text)
            
            # Add spacing between segments
            if i < len(sorted_segments) - 1:
                story_parts.append(" ")
        
        # Add closing section
        story_parts.append("\n\n")
        story_parts.append(self._generate_story_closing(sorted_segments, log_path))
        
        complete_story = "".join(story_parts)
        
        logger.info(f"Combined {len(sorted_segments)} narrative segments into complete story")
        return complete_story
    
    def _get_event_order(self, event_type: str) -> int:
        """
        Get the ordering priority for different event types within a turn.
        
        Args:
            event_type: Type of event
            
        Returns:
            Integer ordering priority (lower numbers first)
        """
        order_map = {
            'initialization': 0,
            'turn_begin': 1,
            'agent_registration': 2,
            'character_action': 3,
            'general_event': 4,
            'error_event': 5,
            'turn_end': 6,
        }
        return order_map.get(event_type, 99)
    
    def _generate_story_opening(self, segments: List[NarrativeSegment], log_path: str) -> str:
        """
        Generate an atmospheric opening for the complete story.
        
        Args:
            segments: All narrative segments for context
            log_path: Original log file path
            
        Returns:
            Opening narrative text
        """
        # Extract context from segments
        all_characters = set()
        all_factions = set()
        
        for segment in segments:
            all_characters.update(segment.character_focus)
            all_factions.update(segment.faction_themes)
        
        # Use template system
        opening_template = self.narrative_templates['opening']['grimdark_dramatic']
        
        context_vars = {
            'location': 'the contested battlefields of the 41st millennium',
            'campaign_id': os.path.basename(log_path)
        }
        
        opening = opening_template.format(**context_vars)
        
        # Add character context if we have notable participants
        if all_characters:
            character_list = list(all_characters)[:3]  # Limit to top 3
            if len(character_list) == 1:
                opening += f" The chronicles focus upon {character_list[0]}, whose choices would echo through the void."
            elif len(character_list) == 2:
                opening += f" The fates of {character_list[0]} and {character_list[1]} intertwined in the crucible of war."
            else:
                opening += f" The destinies of {', '.join(character_list[:-1])}, and {character_list[-1]} converged in this tale of conflict."
        
        return opening
    
    def _generate_story_closing(self, segments: List[NarrativeSegment], log_path: str) -> str:
        """
        Generate an atmospheric closing for the complete story.
        
        Args:
            segments: All narrative segments for context
            log_path: Original log file path
            
        Returns:
            Closing narrative text
        """
        closing_template = self.narrative_templates['closing']['grimdark_dramatic']
        return closing_template
    
    def _generate_empty_narrative(self, log_path: str) -> str:
        """
        Generate a narrative for when no events are found in the log.
        
        Args:
            log_path: Path to the original log file
            
        Returns:
            Basic narrative for empty logs
        """
        return (
            "In the grim darkness of the far future, where there is only war, "
            "this chronicle records a moment of stillness. Perhaps it was the calm "
            "before the storm, or perhaps it was the silence that follows great "
            "devastation. In the vastness of the galaxy, even silence carries weight.\n\n"
            f"Chronicle source: {os.path.basename(log_path)}\n"
            "Status: No significant events recorded\n\n"
            "In the Emperor's name, even the absence of war serves the greater purpose."
        )
    
    def _generate_error_narrative(self, log_path: str, error_message: str) -> str:
        """
        Generate a narrative when processing encounters errors.
        
        Args:
            log_path: Path to the original log file
            error_message: Description of the error encountered
            
        Returns:
            Error narrative with atmospheric flavor
        """
        return (
            "In the grim darkness of the far future, some chronicles are lost to "
            "the corrupting touch of chaos, their words scattered like ash on "
            "the solar winds. This record, though damaged, bears witness to "
            "events that even the Adeptus Administratum could not fully capture.\n\n"
            f"Chronicle source: {os.path.basename(log_path)}\n"
            f"Corruption detected: {error_message}\n\n"
            "Even incomplete records serve the Emperor's truth. In darkness, "
            "we find light. In fragments, we discover purpose."
        )
    
    def _save_narrative_to_file(self, narrative: str, original_log_path: str) -> str:
        """
        Save the generated narrative to a file in the output directory.
        
        Args:
            narrative: Complete narrative text to save
            original_log_path: Path to the original log file for naming
            
        Returns:
            Path to the saved narrative file
            
        Raises:
            OSError: If file writing fails
        """
        try:
            # Generate output filename
            original_name = Path(original_log_path).stem
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_filename = f"{original_name}_narrative_{timestamp}.md"
            output_path = Path(self.output_directory) / output_filename
            
            # Create narrative header
            header = f"""# Campaign Chronicle: {original_name}

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Source:** {os.path.basename(original_log_path)}  
**Chronicler:** ChroniclerAgent v1.0  
**Style:** {self.narrative_style}  

---

"""
            
            # Write the complete narrative file
            with open(output_path, 'w', encoding='utf-8') as file:
                file.write(header + narrative)
            
            logger.info(f"Narrative saved to file: {output_path}")
            return str(output_path)
            
        except Exception as e:
            logger.error(f"Failed to save narrative to file: {str(e)}")
            raise OSError(f"Narrative file save failed: {str(e)}")
    
    # Utility methods for chronicler management and debugging
    
    def get_chronicler_status(self) -> Dict[str, Any]:
        """
        Get comprehensive status information about the chronicler's operation.
        
        Returns:
            Dict containing detailed chronicler status information
        """
        current_time = datetime.now()
        
        return {
            'chronicler_info': {
                'version': '1.0.0',
                'narrative_style': self.narrative_style,
                'output_directory': self.output_directory,
                'max_events_per_batch': self.max_events_per_batch,
            },
            'processing_stats': {
                'events_processed': self.events_processed,
                'narratives_generated': self.narratives_generated,
                'llm_calls_made': self.llm_calls_made,
                'error_count': self.error_count,
                'last_error_time': self.last_error_time.isoformat() if self.last_error_time else None,
            },
            'system_health': {
                'status': 'operational' if self.error_count < 10 else 'degraded',
                'templates_loaded': len(self.narrative_templates),
                'faction_descriptions_loaded': len(self.faction_descriptions),
            },
            'capabilities': {
                'log_parsing': True,
                'llm_integration': True,
                'narrative_combination': True,
                'file_output': self.output_directory is not None,
                'error_recovery': True,
            }
        }
    
    def set_narrative_style(self, style: str) -> bool:
        """
        Change the narrative style for future transcriptions.
        
        Args:
            style: New narrative style ('grimdark_dramatic', 'tactical', 'philosophical')
            
        Returns:
            bool: True if style was set successfully, False if style is invalid
        """
        valid_styles = ['grimdark_dramatic', 'tactical', 'philosophical']
        
        if style not in valid_styles:
            logger.warning(f"Invalid narrative style: {style}. Valid styles: {valid_styles}")
            return False
        
        self.narrative_style = style
        logger.info(f"Narrative style changed to: {style}")
        return True


# Utility functions for ChroniclerAgent management

def create_chronicler_with_output(output_dir: Optional[str] = None) -> ChroniclerAgent:
    """
    Utility function to create a ChroniclerAgent with output directory setup.
    
    Args:
        output_dir: Optional directory path for saving narrative files
                   If None, uses configuration value
        
    Returns:
        ChroniclerAgent instance configured for file output
    """
    try:
        if output_dir is None:
            # Use configuration value
            try:
                config = get_config()
                output_dir = config.chronicler.output_directory
            except Exception as e:
                logger.warning(f"Failed to get output directory from config: {e}")
                output_dir = "demo_narratives"
        
        chronicler = ChroniclerAgent(output_directory=output_dir)
        logger.info(f"ChroniclerAgent created with output directory: {output_dir}")
        return chronicler
    except Exception as e:
        logger.error(f"Failed to create ChroniclerAgent: {e}")
        raise


def batch_transcribe_logs(chronicler: ChroniclerAgent, log_paths: List[str]) -> List[str]:
    """
    Utility function to transcribe multiple campaign logs in batch.
    
    Args:
        chronicler: ChroniclerAgent instance to use
        log_paths: List of paths to campaign log files
        
    Returns:
        List of generated narrative strings
    """
    narratives = []
    
    logger.info(f"Starting batch transcription: {len(log_paths)} logs")
    
    for i, log_path in enumerate(log_paths):
        try:
            logger.info(f"Transcribing log {i + 1}/{len(log_paths)}: {log_path}")
            narrative = chronicler.transcribe_log(log_path)
            narratives.append(narrative)
        except Exception as e:
            logger.error(f"Failed to transcribe log {log_path}: {e}")
            narratives.append(f"ERROR: Failed to transcribe {log_path}")
    
    logger.info(f"Batch transcription completed: {len(narratives)} narratives generated")
    return narratives


# Example usage and testing functions

def example_usage():
    """
    Example usage of the ChroniclerAgent class.
    
    Demonstrates how to create and use ChroniclerAgent for narrative transcription.
    """
    print("ChroniclerAgent Example Usage:")
    print("==============================")
    
    try:
        # Create ChroniclerAgent
        chronicler = ChroniclerAgent()
        print(f"✓ ChroniclerAgent created successfully")
        print(f"  Narrative style: {chronicler.narrative_style}")
        print(f"  Max events per batch: {chronicler.max_events_per_batch}")
        
        # Example transcription (would need actual campaign log file)
        # narrative = chronicler.transcribe_log("campaign_log.md")
        # print(f"✓ Campaign transcribed: {len(narrative)} characters generated")
        
        # Get chronicler status
        status = chronicler.get_chronicler_status()
        print(f"✓ Chronicler status: {status['system_health']['status']}")
        print(f"  Templates loaded: {status['system_health']['templates_loaded']}")
        
        # Test style change
        success = chronicler.set_narrative_style('tactical')
        print(f"✓ Style change: {'Success' if success else 'Failed'}")
        
        print("\nChroniclerAgent is ready for campaign transcription!")
        
    except Exception as e:
        print(f"✗ Example failed: {e}")


if __name__ == "__main__":
    # Run example usage when script is executed directly
    example_usage()