#!/usr/bin/env python3
"""
ChroniclerAgent Core Implementation
==================================

This module implements the ChroniclerAgent class, which serves as the narrative
transcription system for the StoryForge AI Interactive Story Engine. The ChroniclerAgent
transforms structured campaign logs into dramatic narrative stories that capture
the essence of any fictional universe.
"""

import json
import os
import re
import logging
import time
import random
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass, field
from src.event_bus import EventBus
from src.persona_agent import PersonaAgent
from shared_types import CharacterAction

from config_loader import get_config

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class CampaignEvent:
    """
    Represents a parsed event from the campaign log.
    
    Encapsulates all relevant information needed to generate narrative content
    for a specific event in the simulation timeline.
    """
    turn_number: int
    timestamp: str
    event_type: str
    description: str
    participants: List[str] = field(default_factory=list)
    faction_info: Dict[str, str] = field(default_factory=dict)
    action_details: Dict[str, Any] = field(default_factory=dict)
    raw_text: str = ""


@dataclass
class NarrativeSegment:
    """
    Represents a generated narrative segment for a specific event or turn.
    
    Contains the dramatic prose generated by the LLM along with metadata
    for combining segments into a cohesive story.
    """
    turn_number: int
    event_type: str
    narrative_text: str
    character_focus: List[str] = field(default_factory=list)
    faction_themes: List[str] = field(default_factory=list)
    tone: str = "dramatic"
    timestamp: str = ""


class ChroniclerAgent:
    """
    Core implementation of the narrative transcription system.
    
    The ChroniclerAgent transforms structured campaign logs into dramatic narrative prose.
    """
    
    def __init__(self, event_bus: EventBus, output_directory: Optional[str] = None, max_events_per_batch: Optional[int] = None, narrative_style: Optional[str] = None, character_names: Optional[List[str]] = None):
        """
        Initializes the ChroniclerAgent.

        Args:
            event_bus: An instance of the EventBus for decoupled communication.
            output_directory: Optional path to save generated narratives.
            max_events_per_batch: Optional maximum events per batch.
            narrative_style: Optional narrative style.
            character_names: Optional list of character names for story integration.
        """
        logger.info("Initializing ChroniclerAgent...")
        
        self.event_bus = event_bus
        self.narrative_segments: List[NarrativeSegment] = []

        try:
            config = get_config()
            self._config = config
        except Exception as e:
            logger.warning(f"Failed to load configuration, using defaults: {e}")
            self._config = None
        
        self.output_directory = output_directory or (self._config.chronicler.output_directory if self._config else None)
        self.max_events_per_batch = max_events_per_batch or (self._config.chronicler.max_events_per_batch if self._config else 50)
        self.narrative_style = narrative_style or (self._config.chronicler.narrative_style if self._config else "sci_fi_dramatic")
        self.character_names = character_names or []
        
        self.events_processed = 0
        self.narratives_generated = 0
        self.llm_calls_made = 0
        self.error_count = 0
        self.last_error_time: Optional[datetime] = None
        
        try:
            self._initialize_output_directory()
            self._initialize_narrative_templates()
            self.event_bus.subscribe("AGENT_ACTION_COMPLETE", self.handle_agent_action)
            self.event_bus.subscribe("SIMULATION_END", self.handle_simulation_end)
            logger.info("ChroniclerAgent initialized successfully and subscribed to events.")
        except Exception as e:
            logger.error(f"Failed to initialize ChroniclerAgent: {e}")
            raise ValueError(f"ChroniclerAgent initialization failed: {e}")
    
    def _initialize_output_directory(self) -> None:
        """Initializes and validates the output directory."""
        if not self.output_directory:
            logger.info("No output directory specified; narratives will be returned as strings.")
            return
        
        try:
            output_path = Path(self.output_directory)
            output_path.mkdir(parents=True, exist_ok=True)
            if not output_path.is_dir():
                raise ValueError(f"Output path is not a directory: {self.output_directory}")
            
            # Test write permissions
            (output_path / "test.tmp").touch()
            (output_path / "test.tmp").unlink()
            logger.info(f"Output directory validated: {self.output_directory}")
        except Exception as e:
            raise OSError(f"Output directory initialization failed: {e}")
    
    def _initialize_narrative_templates(self) -> None:
        """Initializes narrative generation templates."""
        self.narrative_templates = {
            'opening': "In the vast expanse of the cosmos, a story unfolds.",
            'agent_registration': "{character_name} of the {faction} has joined the conflict.",
            'character_action': "{character_name} chose to {action_type}. {action_description}",
            'turn_summary': "As turn {turn_number} concludes, the situation is as follows: {summary_text}",
            'closing': "Thus concludes this chapter of the saga."
        }
        self.faction_descriptions = {'Unknown': 'warriors of unclear allegiance'}
        logger.info("Narrative templates initialized.")
    
    def handle_agent_action(self, agent: PersonaAgent, action: Optional[CharacterAction]):
        """Handles the AGENT_ACTION_COMPLETE event."""
        if not action:
            return

        character_name = agent.character_data.get('name', 'Unknown')
        description = f"{character_name} decided to {action.action_type}"
        if action.reasoning:
            description += f": {action.reasoning}"

        event = CampaignEvent(
            turn_number=0, # This will need to be passed in the event payload
            timestamp=datetime.now().isoformat(),
            event_type='character_action',
            description=description
        )
        narrative_text = self._generate_event_narrative(event)
        if narrative_text:
            self.narrative_segments.append(NarrativeSegment(
                turn_number=event.turn_number,
                event_type=event.event_type,
                narrative_text=narrative_text
            ))

    def handle_simulation_end(self):
        """Handles the SIMULATION_END event, finalizing the narrative."""
        logger.info("Simulation ended, generating final narrative.")
        complete_story = self._combine_narrative_segments(self.narrative_segments)
        if self.output_directory:
            self._save_narrative_to_file(complete_story, "simulation_narrative")

    def _generate_event_narrative(self, event: CampaignEvent) -> str:
        """Generates narrative prose for a single event."""
        prompt = self._create_narrative_prompt(event)
        return self._call_llm(prompt)

    def _create_narrative_prompt(self, event: CampaignEvent) -> str:
        """Creates a contextual prompt for LLM narrative generation."""
        return f"Narrate this event dramatically: {event.description}"

    def _call_llm(self, prompt: str) -> str:
        """Makes an LLM API call for narrative generation."""
        logger.debug(f"ChroniclerAgent calling LLM with prompt: {prompt}")
        time.sleep(0.1) # Simulate API call
        self.llm_calls_made += 1
        # Fallback for now
        return f"A noteworthy event occurred: {prompt.split(':')[-1].strip()}"

    def _combine_narrative_segments(self, segments: List[NarrativeSegment]) -> str:
        """Combines individual narrative segments into a cohesive story."""
        if not segments: return "No significant events to narrate."
        
        story = self.narrative_templates['opening'] + "\n\n"
        story += "\n\n".join([s.narrative_text for s in sorted(segments, key=lambda x: x.turn_number)])
        story += "\n\n" + self.narrative_templates['closing']
        return story

    def _save_narrative_to_file(self, narrative: str, base_filename: str) -> str:
        """Saves the generated narrative to a file."""
        filename = f"{base_filename}_narrative_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        output_path = Path(self.output_directory) / filename
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(f"# Narrative for {base_filename}\n\n{narrative}")
        
        logger.info(f"Narrative saved to: {output_path}")
        return str(output_path)

def example_usage():
    """Example usage of the ChroniclerAgent class."""
    print("ChroniclerAgent class is ready for use.")

if __name__ == "__main__":
    example_usage()