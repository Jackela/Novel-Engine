# Ralph Progress Log
Started: Sun Feb  1 12:27:10     2026
---

## WORLD-001 - 2026-02-01
- What I implemented: Added aliases, archetype, traits, appearance fields to CharacterProfile dataclass and CharacterSummary Pydantic schema. Updated frontend TypeScript schemas and mock handlers to match.
- Pattern discovered: CharacterProfile is a frozen dataclass (immutable), so new fields must have Optional types with None defaults for backward compatibility.
- Gotcha for future: When updating CharacterSummary schema, also update frontend/src/mocks/handlers.ts to include the new required fields, otherwise TypeScript type-check will fail.

## WORLD-002 - 2026-02-01
- What I implemented: Created CharacterProfileForm.tsx with react-hook-form and zod validation. Includes tag-based inputs for aliases and traits using Badge components. Uses shadcn/ui Input, Textarea, and Badge components. Name field is required with inline validation errors.
- Pattern discovered: When using zodResolver with strict TypeScript, the form values type must be explicitly defined and cast with `as Resolver<FormType>` to avoid type mismatch between zod's inferred optional fields and the form's runtime values.
- Gotcha for future: Use `useMemo` to stabilize array values from `form.watch()` when they're used in `useCallback` dependencies, otherwise ESLint warns about unstable deps causing re-renders.

## WORLD-003 - 2026-02-01
- What I implemented: Created Relationship entity with EntityType (5 types) and RelationshipType (12 types) enums. Implemented type compatibility validation (e.g., ROMANTIC requires CHARACTER entities). Created IRelationshipRepository protocol and InMemoryRelationshipRepository with entity-indexed lookups. Added CRUD API endpoints at /api/relationships with by-entity and between-entities queries. Wrote 33 unit tests covering all validation and query methods.
- Pattern discovered: World domain entities inherit from a base Entity class in src/contexts/world/domain/entities/entity.py that provides id, created_at, updated_at, version fields and domain event support. New entities should extend this base class.
- Gotcha for future: When creating new routers, remember to register them in TWO places in main_api_server.py's _register_legacy_routes: once without prefix and once with /api prefix for backward compatibility.

## WORLD-004 - 2026-02-01
- What I implemented: Created RelationshipGraph component using @xyflow/react v12. Added CharacterNode custom node with avatar placeholder, name, and archetype badge. Configured shadcn theme-matching styles for nodes, edges, handles, MiniMap, and Controls. Integrated graph into WorldPage replacing placeholder WorldMap.
- Pattern discovered: @xyflow/react v12 requires custom node data types to `extends Record<string, unknown>`, then create a `NodeType = Node<NodeData>` and use `NodeProps<NodeType>` for component props. This is different from older reactflow package patterns.
- Gotcha for future: The package name is `@xyflow/react` (already installed), not `reactflow`. The library was renamed. Use `satisfies NodeTypes` instead of direct type annotation for nodeTypes registry to avoid strict type errors with custom nodes.

## WORLD-005 - 2026-02-01
- What I implemented: Connected RelationshipGraph to API data (Characters + Relationships). Installed @dagrejs/dagre for automatic graph layout. Added Relationship schemas (EntityType, RelationshipType) to frontend. Created mock handlers for /api/relationships. Implemented color-coded edges (green=ally, red=enemy, blue=family). Added edge animation for enemy/romantic relationships. Implemented node selection with MiniMap highlighting.
- Pattern discovered: When using useEdgesState with custom Edge types, you must specify the type parameter: `useEdgesState<Edge>([])`. Without it, TypeScript infers `never[]` which causes assignment errors.
- Gotcha for future: Avoid `satisfies` with optional properties in object literals when the type has optional fields. Instead, build the object conditionally: `const data: CharacterNodeData = { name }; if (archetype) data.archetype = archetype;`. This avoids type narrowing issues with undefined vs optional.

## WORLD-006 - 2026-02-01
- What I implemented: VERIFICATION PASS - Location hierarchy already fully implemented. Verified `parent_location_id` (line 187), `child_location_ids` (line 188), plus `add_child_location()`, `remove_child_location()`, `set_parent_location()`, and `_validate_hierarchy()` methods. LocationType enum has 26 types including CONTINENT, REGION, CITY, TOWN, VILLAGE, CASTLE, DUNGEON, TEMPLE, etc. All 17 Location tests pass in test_world_entities.py.
- Pattern discovered: Location.child_location_ids directly provides child IDs without needing a get_sub_locations() method. Returning full child Location objects would require repository lookup, which violates domain entity purity (entities should not depend on infrastructure). The current design correctly keeps hierarchy data as IDs.
- Gotcha for future: The test file is test_world_entities.py (not test_location.py as PRD suggested). Multiple world entities (WorldSetting, Faction, Location, HistoryEvent) are tested in a single comprehensive file.

## WORLD-007 - 2026-02-01
- What I implemented: Created LocationTree.tsx recursive component using shadcn Collapsible. Added LocationType enum (27 types) with matching lucide-react icons. Implemented tree building from flat array with parent_location_id. Added keyboard accessibility (Enter/Space to select, Arrow keys to expand/collapse). Updated WorldLocationSchema with parent_location_id and child_location_ids fields. Created mock locations API with 3-level hierarchy (Continent > Region > City/Fortress).
- Pattern discovered: With `exactOptionalPropertyTypes: true` in tsconfig, optional props must use `prop: T | undefined` (explicit undefined) not `prop?: T` when passing potentially undefined values to child components. Also, avoid `new Map<K,V>()` constructor - use `Record<K,V>` object or `new Map(entries)` to avoid type inference issues with lucide-react's global type augmentation.
- Gotcha for future: The shadcn Collapsible component must be installed separately via `npx shadcn@latest add collapsible`. It's not included by default. The component is thin (just re-exports from @radix-ui/react-collapsible) but provides consistent styling hooks.

## WORLD-008 - 2026-02-01
- What I implemented: Created Item entity with ItemType (5 types: WEAPON/ARMOR/CONSUMABLE/KEY_ITEM/MISC) and ItemRarity (4 levels: COMMON/UNCOMMON/RARE/LEGENDARY) enums. Added inventory: List[str] to Character aggregate with give_item/remove_item/has_item methods. Created IItemRepository protocol and InMemoryItemRepository with type/rarity indexes. Added full CRUD API at /api/items plus /api/characters/{id}/give-item and /api/characters/{id}/remove-item/{item_id} endpoints. Wrote 35 unit tests covering entity validation, operations, factory methods, and serialization.
- Pattern discovered: Inventory management belongs on the Character aggregate (mutable state) rather than CharacterProfile (frozen dataclass). The aggregate pattern allows coordinating inventory changes with version updates and domain events.
- Gotcha for future: When creating router endpoints that cross domain boundaries (e.g., /characters/{id}/give-item relates to both items and characters), consider using a separate APIRouter (character_inventory_router) to keep concerns modular while still allowing registration under different prefixes.

## WORLD-009 - 2026-02-01
- What I implemented: Created InventoryTab component with full CRUD capabilities. Updated CharacterDetailsDialog to use shadcn Tabs with Profile/Inventory tabs. Added Item schemas (ItemType, ItemRarity, ItemResponse, ItemListResponse) to frontend types. Created mock handlers for /api/items and /api/characters/:id/inventory endpoints. Installed shadcn/ui tabs component. Implemented item list with type-based icons (lucide-react), rarity badges with color coding, remove button, Give Item dialog with item select, and type filter dropdown.
- Pattern discovered: When building complex form components that exceed ESLint's max-lines-per-function (80 lines), break them into smaller sub-components (ItemRow, GiveItemDialog, ItemIcon, RarityBadge) that handle specific concerns. This keeps each function focused and testable.
- Gotcha for future: The shadcn/ui tabs component must be installed separately via `npx shadcn@latest add tabs -y`. It's built on @radix-ui/react-tabs. When using react-query mutations, the `error` property is typed as `Error | null`, so check with `error instanceof Error` before accessing `.message`.

## WORLD-010 - 2026-02-01
- What I implemented: Created LoreEntry entity with LoreCategory enum (HISTORY/CULTURE/MAGIC/TECHNOLOGY). Implemented ILoreEntryRepository protocol and InMemoryLoreEntryRepository with category and tag indexes. Added full CRUD API at /api/lore plus search endpoint at /api/lore/search with title, tag, and category filtering. Added Pydantic schemas for requests and responses. Wrote 42 unit tests for entity and 22 API integration tests.
- Pattern discovered: FastAPI route order matters - static routes (like /search) must be defined BEFORE parameterized routes (like /{entry_id}), otherwise "search" gets matched as an entry_id. Also, the persistence/__init__.py was importing SQLAlchemy models that had a "metadata" attribute name conflict; fixed with lazy imports using __getattr__.
- Gotcha for future: When adding new routers, must register in BOTH src/api/app.py (used by api_server.py for tests) AND src/api/main_api_server.py (used for production). The app.py registration was missing for relationships, items, and lore routers - tests fail with 404 if only main_api_server.py is updated.

## WORLD-011 - 2026-02-01
- What I implemented: Created WikiDashboard.tsx at /world/wiki route as a central knowledge base view. Used shadcn Table component (installed via `npx shadcn@latest add table -y`) to display a unified list of Lore, Characters, Locations, and Items. Implemented debounced search (300ms) filtering by name, tags, and subtype. Added type dropdown filter. Each row shows type-specific icon (lucide-react), color-coded type badge, tags (max 3 + overflow indicator), and formatted date. Row clicks navigate to relevant detail pages. Added Lore schemas (LoreCategory, LoreEntryResponse, LoreEntryListResponse) to frontend types. Created mock lore entries and API handlers.
- Pattern discovered: When splitting components to avoid max-lines-per-function warnings, extract pure transform functions (transformLoreEntries, transformCharacters) separately from React components (WikiFilters, WikiTableRow). This keeps data transformation logic testable and components focused on rendering.
- Gotcha for future: With `exactOptionalPropertyTypes: true` in tsconfig, optional interface properties must explicitly include `| undefined` (e.g., `subtype?: string | undefined`) when the source data may be undefined. Using just `subtype?: string` causes TS2379 assignment errors.

## WORLD-012 - 2026-02-01
- What I implemented: Created CharacterProfileGenerator service in src/contexts/world/infrastructure/generators/character_profile_generator.py. Implemented LLMCharacterProfileGenerator using Gemini API with structured JSON output matching CharacterProfile schema (name, aliases, archetype, traits, appearance, backstory, motivations, quirks). Added MockCharacterProfileGenerator for deterministic testing. Created CharacterProfileGenerator factory class that selects generator based on MOCK_LLM environment variable. Wrote 36 comprehensive unit tests covering parsing, prompts, integration, and edge cases.
- Pattern discovered: Existing LLMCharacterGenerator in character context returns simple CharacterGenerationResult (name, tagline, bio, visual_prompt, traits). The new CharacterProfileGenerator returns richer data matching the CharacterProfile value object's new WORLD-001 fields. Keep them separate - different use cases.
- Gotcha for future: The MOCK_LLM flag supports multiple formats: "true", "1", "yes" (case-insensitive). When creating similar generators, follow the factory pattern with Protocol-based dependency injection to allow easy testing and swapping implementations.

## WORLD-013 - 2026-02-01
- What I implemented: Added 'Auto-Generate' button with Sparkles icon to CharacterProfileForm.tsx. Created backend API endpoint POST /api/generation/character-profile in generation.py router. Added CharacterProfileGenerationRequest/Response Pydantic schemas. Added corresponding Zod schemas and TypeScript types in frontend. Added generateCharacterProfile function in generationApi.ts. Installed shadcn/ui sonner component for toast notifications. Added Toaster to AppProviders. Created mock handler for /api/generation/character-profile in handlers.ts with archetype-based response templates.
- Pattern discovered: The shadcn/ui sonner component by default uses `next-themes` which is for Next.js projects. For React+Vite projects, remove the useTheme hook and accept theme as a prop with a default value of 'system'. Also, sonner exports ToasterProps directly which is cleaner than using ComponentProps.
- Gotcha for future: When adding new shadcn/ui components via `npx shadcn@latest add`, always check if they have Next.js-specific dependencies (like next-themes) and adapt them for the project's tech stack. The sonner component needed modification to work with the standard React + Vite setup.
