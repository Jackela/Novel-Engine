# Ralph Progress - UI Rescue Phase

## UI-FIX-001 - 2026-01-30
- What I implemented: Fixed catch-all route redirect by changing path from '*' to '$' (TanStack Router splat syntax)
- Pattern discovered: TanStack Router uses '$' for splat/catch-all routes, not '*' like traditional routers
- Gotcha for future: The catch-all route was showing "Not Found" paragraph instead of redirecting because of wrong syntax. Always use '$' for TanStack Router wildcards.

## TEST-FIX-001 - 2026-01-30
- What I implemented: Fixed Playwright headless mode default and added browser cleanup in global teardown
- Changes made:
  1. Changed `headless: process.env.CI ? true : false` to `headless: process.env.HEADED !== 'true'` in both playwright configs
  2. Added `cleanupBrowserContexts()` function to global-teardown.ts that closes lingering browser contexts
  3. Added Windows-specific orphan process cleanup via taskkill
- Pattern discovered: Use inverted env var logic (HEADED=true to show browser) instead of CI detection for headless mode
- Gotcha for future: Always default to headless mode and use explicit opt-in for headed mode during debugging

## MOCK-001 - 2026-01-30
- What I implemented: LLM Mock Infrastructure for E2E Testing
- Files created:
  1. `tests/mocks/llm_handlers.ts` - Main mock implementation with Page route interceptors
  2. `frontend/tests/e2e/utils/llmMocks.ts` - ESM-compatible copy for Playwright tests
  3. `frontend/tests/e2e/llm-mock-verification.spec.ts` - Verification tests
- Endpoints mocked:
  - POST /api/generate
  - POST /api/generation/character
  - POST /api/generation/scene
  - POST /api/narratives/stream (SSE)
  - GET/POST /api/orchestration/narrative
- Pattern discovered: TypeScript files in `tests/` are CommonJS by default, Playwright tests in `frontend/tests/e2e/` require ESM. Need to maintain parallel implementations or use re-exports
- Gotcha for future: When using `page.route()` with `page.evaluate()`, cannot use `about:blank` as the page - need to navigate to actual app URL first for relative fetch URLs to work
- Verification: All 5 tests pass with MOCK_LLM=true in 8.1s, properly skipped when env var not set

## NAR-001 - 2026-01-31
- What I implemented: Story & Chapter domain entities for the Narrative bounded context
- Files created:
  1. `src/contexts/narrative/domain/__init__.py` - Domain layer exports
  2. `src/contexts/narrative/domain/entities/__init__.py` - Entities package
  3. `src/contexts/narrative/domain/entities/story.py` - Story aggregate root with StoryStatus enum
  4. `src/contexts/narrative/domain/entities/chapter.py` - Chapter entity with ChapterStatus enum
  5. `src/contexts/narrative/domain/value_objects/__init__.py` - Value objects package (placeholder)
  6. `tests/unit/contexts/narrative/domain/entities/test_story_entity.py` - 28 unit tests for Story
  7. `tests/unit/contexts/narrative/domain/entities/test_chapter_entity.py` - 21 unit tests for Chapter
- Attributes implemented:
  - Story: id, title, summary, status (DRAFT/PUBLISHED), created_at, updated_at, _chapters
  - Chapter: id, story_id, title, summary, order_index, status (DRAFT/PUBLISHED), created_at, updated_at
- Pattern discovered: Used dataclass with field(default_factory=...) for mutable defaults and timestamps
- Gotcha for future: Story.chapters returns a sorted copy (by order_index) to prevent external modification of internal list
- Verification: All 49 tests pass in 0.26s

## NAR-002 - 2026-01-31
- What I implemented: Scene & Beat domain entities for atomic narrative units
- Files created:
  1. `src/contexts/narrative/domain/entities/scene.py` - Scene entity with SceneStatus enum (DRAFT/GENERATING/REVIEW/PUBLISHED)
  2. `src/contexts/narrative/domain/entities/beat.py` - Beat entity with BeatType enum (ACTION/DIALOGUE/REACTION/REVELATION/TRANSITION/DESCRIPTION)
  3. `tests/unit/contexts/narrative/domain/entities/test_scene_entity.py` - 43 unit tests for Scene
  4. `tests/unit/contexts/narrative/domain/entities/test_beat_entity.py` - 41 unit tests for Beat
- Attributes implemented:
  - Scene: id, chapter_id, title, summary, order_index, status, location, created_at, updated_at, _beats
  - Beat: id, scene_id, content, order_index, beat_type, notes, created_at, updated_at
- Key methods:
  - Scene.reorder_beats(beat_ids): Atomic reordering for drag-and-drop UI
  - Scene.add_beat/remove_beat/get_beat: Beat management with scene_id validation
  - Beat.append_content: Streaming support for LLM generation
  - Beat.word_count/is_empty: Utility methods for writing progress tracking
- Pattern discovered: SceneStatus has GENERATING state for LLM generation workflow, while Beat allows empty content (placeholder beats)
- Gotcha for future: Scene.beats returns sorted copy by order_index; reorder_beats() validates beat_ids match exactly (no missing or extra)
- Verification: All 120 Narrative domain tests pass in 0.42s

## NAR-003 - 2026-01-31
- What I implemented: Narrative Repository Port (INarrativeRepository) and InMemory implementation
- Files created:
  1. `src/contexts/narrative/application/__init__.py` - Application layer package
  2. `src/contexts/narrative/application/ports/__init__.py` - Ports package
  3. `src/contexts/narrative/application/ports/narrative_repository_port.py` - INarrativeRepository protocol (ABC)
  4. `src/contexts/narrative/infrastructure/__init__.py` - Infrastructure layer package
  5. `src/contexts/narrative/infrastructure/repositories/__init__.py` - Repositories package
  6. `src/contexts/narrative/infrastructure/repositories/in_memory_narrative_repository.py` - InMemory implementation
  7. `tests/unit/contexts/narrative/infrastructure/repositories/test_in_memory_narrative_repository.py` - 25 unit tests
- Port methods defined:
  - save(story): Persist a Story aggregate
  - get_by_id(story_id): Load a Story by UUID
  - list_all(): Get all stories sorted by created_at
  - delete(story_id): Remove a story, return success bool
  - exists(story_id): Check existence without loading aggregate
- Pattern discovered: InMemory implementation uses deepcopy on both save AND get to prevent external mutation of stored entities
- Gotcha for future: list_all() returns sorted by created_at (oldest first) for consistent ordering in tests and UI
- Verification: All 145 Narrative context tests pass in 0.44s

## NAR-004 - 2026-01-31
- What I implemented: Structure API (CRUD) for managing story outline via REST endpoints
- Files created:
  1. `src/api/routers/structure.py` - 15+ REST endpoints for Story/Chapter/Scene CRUD
  2. Added Pydantic schemas in `src/api/schemas.py`: StoryCreateRequest, StoryUpdateRequest, StoryResponse, StoryListResponse, ChapterCreateRequest, ChapterUpdateRequest, ChapterResponse, ChapterListResponse, SceneCreateRequest, SceneUpdateRequest, SceneResponse, SceneListResponse, MoveChapterRequest, MoveSceneRequest, StructureErrorResponse
  3. Updated `docs/api/openapi.current.json` via generate_openapi.py
- Endpoints implemented:
  - Stories: POST/GET/PATCH/DELETE /structure/stories
  - Chapters: POST/GET/PATCH/DELETE /structure/stories/{id}/chapters
  - Scenes: POST/GET/PATCH/DELETE /structure/stories/{id}/chapters/{id}/scenes
  - Move operations: POST .../move for reordering
- Pattern discovered: Used dependency injection with `Depends(get_repository)` for testability; scenes stored in module-level dict for MVP (not in Story aggregate) to avoid repository interface changes
- Gotcha for future: Scene storage is separate from Story aggregate - scenes are stored in `_scenes` dict, not persisted through INarrativeRepository. This is MVP-only; production should extend repository to handle Scene persistence
- Verification: All 145 Narrative tests pass, frontend type-check passes, ruff lint passes

## NAR-005 - 2026-01-31
- What I implemented: SSE streaming endpoint for narrative generation with MOCK_LLM flag
- Files created:
  1. `src/api/routers/narrative_generation.py` - SSE streaming router with POST /narrative/generate/stream
  2. `tests/unit/api/routers/test_narrative_generation_router.py` - 23 unit tests covering models, mock mode, and endpoint
  3. `scripts/verify_stream_endpoint.py` - Manual verification script using httpx
- Key features:
  - `is_mock_mode()`: Checks MOCK_LLM env var (true/1/yes = enabled)
  - `GenerateStreamRequest`: Pydantic model with scene_id, prompt, context, max_tokens (50-4000)
  - `StreamChunk`: Pydantic model for SSE events (type: chunk/done/error)
  - `MOCK_STORY_LINES`: 18-line hardcoded gothic story for mock streaming
  - `generate_mock_stream()`: Async generator simulating LLM delay (50-150ms per line)
  - `_sse_generator()`: SSE-formatted output with metadata on completion
- Endpoint: POST /api/narrative/generate/stream
  - Returns text/event-stream with Cache-Control: no-cache
  - Chunks have sequence numbers for ordering
  - Done event includes metadata: total_chunks, total_characters, generation_time_ms, mock_mode
- Pattern discovered: FastAPI StreamingResponse with async generator works well for SSE; use media_type="text/event-stream"
- Gotcha for future: Real LLM mode falls back to mock for now; production needs actual LLM service integration
- Verification: All 23 new tests pass in 17.7s, endpoint returns proper SSE format

## NAR-006 - 2026-01-31
- What I implemented: Installed Tiptap and dnd-kit dependencies, created minimal EditorComponent
- Files created:
  1. `frontend/src/components/narrative/EditorComponent.tsx` - Tiptap-based rich text editor
- Dependencies added:
  - @tiptap/react, @tiptap/starter-kit, @tiptap/pm - Rich text editor framework
  - @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities - Drag-and-drop functionality
- Component features:
  - Uses StarterKit extension (bold, italic, headings, lists, etc.)
  - Accepts initialContent prop (defaults to "Hello World")
  - onChange callback for content changes
  - Tailwind CSS styling with shadcn/ui design tokens
  - data-testid for E2E testing
- Pattern discovered: Tiptap requires @tiptap/pm package for ProseMirror dependencies to resolve correctly
- Gotcha for future: Component is minimal - will need toolbar and streaming integration in NAR-008/NAR-011
- Verification: npm run build succeeds, type-check passes, lint passes (no errors)

## NAR-007 - 2026-01-31
- What I implemented: NarrativeSidebar component for story outline navigation
- Files created:
  1. `frontend/src/components/narrative/NarrativeSidebar.tsx` - Tree-view sidebar with collapsible chapters and scene selection
- Component features:
  - Uses shadcn `ScrollArea` for scrollable content
  - Tree-view hierarchy: Chapters (collapsible) > Scenes
  - Active scene highlighting via `bg-primary text-primary-foreground`
  - Status badges (draft/generating/review/published) with color coding
  - Mock data export (`MOCK_CHAPTERS`) for testing/development
  - Accessible: keyboard navigation, ARIA labels, focus rings
- Types exported: `OutlinerChapter`, `OutlinerScene` matching backend response schemas
- Pattern discovered: TypeScript `exactOptionalPropertyTypes: true` requires explicit `| undefined` in component props, not just `?` optional marker
- Gotcha for future: When passing optional props from parent to child, use explicit union types `string | undefined` instead of optional marker `?:` to satisfy exactOptionalPropertyTypes
- Verification: type-check passes, lint passes (warnings only), build succeeds, 145 pytest tests pass

## NAR-008 - 2026-01-31
- What I implemented: Enhanced EditorComponent with toolbar and NarrativeEditorLayout with 20%/80% split
- Files created/modified:
  1. `frontend/src/components/narrative/EditorComponent.tsx` - Added EditorToolbar with Bold, Italic, H1, H2 toggles
  2. `frontend/src/components/narrative/NarrativeEditorLayout.tsx` - New layout component combining sidebar (20%) and editor (80%)
  3. `frontend/src/components/ui/toggle.tsx` - Added shadcn/ui Toggle component via `npx shadcn@latest add toggle`
  4. `frontend/src/components/narrative/NarrativeSidebar.tsx` - Fixed prop types for exactOptionalPropertyTypes
- Component features:
  - EditorToolbar: Uses shadcn Toggle components with lucide icons (Bold, Italic, Heading1, Heading2)
  - Toggle state syncs with Tiptap editor state via `editor.isActive()`
  - Editor uses prose typography classes for clean styling
  - Layout uses flexbox with min/max width constraints for sidebar (200-300px)
  - data-testid attributes added for E2E testing
- Pattern discovered: shadcn Toggle component uses `data-[state=on]:bg-accent` for pressed state styling
- Gotcha for future: Need @radix-ui/react-toggle dependency (auto-installed by shadcn add toggle)
- Verification: type-check passes, lint passes (warnings only), build succeeds, 145 pytest tests pass

## NAR-009 - 2026-01-31
- What I implemented: Connected NarrativeSidebar to Structure API for real data loading
- Files created/modified:
  1. `frontend/src/types/schemas.ts` - Added Narrative Structure Zod schemas (StoryResponseSchema, ChapterResponseSchema, SceneResponseSchema, etc.)
  2. `frontend/src/lib/api/narrativeApi.ts` - Full CRUD API client for stories/chapters/scenes with Zod validation
  3. `frontend/src/hooks/useStoryStructure.ts` - Hook for loading and managing story structure with loading/error states
  4. `frontend/src/lib/api/index.ts` - Exported new narrative API functions
  5. `frontend/src/components/narrative/NarrativeEditorLayout.tsx` - Integrated useStoryStructure hook with fallback to mock data
- API functions implemented:
  - Stories: listStories, getStory, createStory, updateStory, deleteStory
  - Chapters: listChapters, getChapter, createChapter, updateChapter, deleteChapter, moveChapter
  - Scenes: listScenes, getScene, createScene, updateScene, deleteScene, moveScene
- Hook features:
  - loadStories(): Load all stories and auto-select first one
  - selectStory(id): Switch to a different story
  - refresh(): Reload current story structure
  - addStory/addChapter/addScene: Create new items with auto-refresh
  - Parallel loading of scenes for all chapters
- Layout integration:
  - Added storyId and useMockData props for flexible data sourcing
  - Loading spinner during initial fetch
  - Error state with retry button
  - Graceful fallback to mock data when backend unavailable
- Pattern discovered: When array operations might return undefined (e.g., `array[0]`), use explicit variable assignment and null check for TypeScript strictness
- Gotcha for future: useStoryStructure loads scenes for each chapter in parallel - with many chapters this could create many concurrent requests. Consider adding rate limiting or lazy loading for large stories
- Verification: type-check passes, lint passes (warnings only for function length), build succeeds, 145 pytest tests pass

## NAR-010 - 2026-01-31
- What I implemented: SSE streaming hook for narrative generation
- Files created:
  1. `frontend/src/hooks/useStoryStream.ts` - Full SSE streaming hook with fetch-based ReadableStream
- Hook features:
  - `startStream(request)`: Start SSE connection via fetch POST (not EventSource since POST required)
  - `stopStream()`: Abort controller cancellation for user-initiated stop
  - `reset()`: Clear buffer and reset all state
  - `buffer`: Accumulated text from all chunks
  - `isStreaming`: Current streaming status
  - `error`: Error message on failure
  - `metadata`: Generation metadata on completion (total_chunks, total_characters, generation_time_ms, mock_mode)
  - `isComplete`: Success completion flag
- Callbacks:
  - `onChunk(content, sequence)`: Called for each incoming chunk
  - `onComplete(metadata)`: Called on successful stream completion
  - `onError(error)`: Called on streaming errors
- Pattern discovered: EventSource only supports GET requests; our endpoint uses POST. Used fetch with ReadableStream and manual SSE parsing instead
- Gotcha for future: SSE lines need manual parsing (split by "data: " prefix). AbortController needed for fetch cancellation
- Verification: type-check passes, lint passes (warnings only for function length/complexity), build succeeds, 2731 pytest tests pass

## NAR-011 - 2026-01-31
- What I implemented: Integrated useStoryStream hook into EditorComponent for live streaming text insertion
- Files modified:
  1. `frontend/src/components/narrative/EditorComponent.tsx` - Added streaming integration with Generate/Stop buttons
  2. `frontend/src/components/narrative/NarrativeEditorLayout.tsx` - Pass sceneId to EditorComponent
  3. `frontend/src/hooks/useStoryStream.ts` - Fixed exactOptionalPropertyTypes for StreamRequest interface
- Key features:
  - EditorToolbar now has Generate button (Sparkles icon) and Stop button (Square icon) during streaming
  - "Generating..." indicator banner with spinner animation shows during streaming
  - Text is inserted at cursor position using Tiptap's `insertContentAt()` method
  - Cursor position tracked via `insertPositionRef` - saved when generation starts, updated as chunks arrive
  - Formatting toolbar toggles (Bold, Italic, H1, H2) are disabled during streaming
  - Editor becomes read-only during streaming (`editable: editable && !isStreaming`)
  - Error state displays below toolbar when streaming fails
  - Props added: sceneId, prompt, context for generation parameters
- Pattern discovered: Tiptap's `insertContentAt(position, content)` is ideal for streaming - it inserts at exact position without moving cursor. Need to track and update position as content grows
- Gotcha for future: Editor becomes read-only during streaming to prevent conflicts. Format toggles are disabled. User can only Stop the generation
- Verification: type-check passes, lint passes (warnings only), build succeeds, 145 narrative tests pass, 89 e2e tests pass

## NAR-012 - 2026-01-31
- What I implemented: E2E test for the full narrative generation flow (The Ghostwriter Test)
- Files created:
  1. `frontend/tests/e2e/narrative-gen.spec.ts` - 3 BDD-style E2E tests covering:
     - Full generation flow: Navigate to editor → Click New Chapter → Assert content appears
     - Cancel flow: Verify generating indicator and Cancel button during streaming
     - Error handling: Verify graceful error display when API fails
- Key test techniques:
  - `prepareGuestSession(page)` to bypass protected route auth
  - Mock SSE endpoint (`/api/narratives/stream`) with `createMockNarrativeSSE()` helper
  - Use `.first()` for locators that may match multiple elements (generating indicator)
  - Wait for content assertion instead of checking indicator visibility for completion
- Test covers NAR-012 acceptance criteria:
  1. Create Chapter via UI - uses "New Chapter" button
  2. Click Generate button - via New Chapter button which triggers startStream
  3. Assert Tiptap editor content becomes non-empty - verify story text appears
- Pattern discovered: Use `page.route()` with `{ times: 1 }` option to override mock for specific test scenarios without affecting beforeEach setup
- Gotcha for future: Multiple `[data-testid="generating-indicator"]` elements exist during streaming states; always use `.first()` or more specific selectors
- Verification: All 3 narrative-gen tests pass in 8.5s, type-check passes, lint passes (warnings only)
