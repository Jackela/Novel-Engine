# Ralph Progress Log
Started: Sun Feb  1 12:27:10     2026
---

## WORLD-001 - 2026-02-01
- What I implemented: Added aliases, archetype, traits, appearance fields to CharacterProfile dataclass and CharacterSummary Pydantic schema. Updated frontend TypeScript schemas and mock handlers to match.
- Pattern discovered: CharacterProfile is a frozen dataclass (immutable), so new fields must have Optional types with None defaults for backward compatibility.
- Gotcha for future: When updating CharacterSummary schema, also update frontend/src/mocks/handlers.ts to include the new required fields, otherwise TypeScript type-check will fail.

## WORLD-002 - 2026-02-01
- What I implemented: Created CharacterProfileForm.tsx with react-hook-form and zod validation. Includes tag-based inputs for aliases and traits using Badge components. Uses shadcn/ui Input, Textarea, and Badge components. Name field is required with inline validation errors.
- Pattern discovered: When using zodResolver with strict TypeScript, the form values type must be explicitly defined and cast with `as Resolver<FormType>` to avoid type mismatch between zod's inferred optional fields and the form's runtime values.
- Gotcha for future: Use `useMemo` to stabilize array values from `form.watch()` when they're used in `useCallback` dependencies, otherwise ESLint warns about unstable deps causing re-renders.

## WORLD-003 - 2026-02-01
- What I implemented: Created Relationship entity with EntityType (5 types) and RelationshipType (12 types) enums. Implemented type compatibility validation (e.g., ROMANTIC requires CHARACTER entities). Created IRelationshipRepository protocol and InMemoryRelationshipRepository with entity-indexed lookups. Added CRUD API endpoints at /api/relationships with by-entity and between-entities queries. Wrote 33 unit tests covering all validation and query methods.
- Pattern discovered: World domain entities inherit from a base Entity class in src/contexts/world/domain/entities/entity.py that provides id, created_at, updated_at, version fields and domain event support. New entities should extend this base class.
- Gotcha for future: When creating new routers, remember to register them in TWO places in main_api_server.py's _register_legacy_routes: once without prefix and once with /api prefix for backward compatibility.

## WORLD-004 - 2026-02-01
- What I implemented: Created RelationshipGraph component using @xyflow/react v12. Added CharacterNode custom node with avatar placeholder, name, and archetype badge. Configured shadcn theme-matching styles for nodes, edges, handles, MiniMap, and Controls. Integrated graph into WorldPage replacing placeholder WorldMap.
- Pattern discovered: @xyflow/react v12 requires custom node data types to `extends Record<string, unknown>`, then create a `NodeType = Node<NodeData>` and use `NodeProps<NodeType>` for component props. This is different from older reactflow package patterns.
- Gotcha for future: The package name is `@xyflow/react` (already installed), not `reactflow`. The library was renamed. Use `satisfies NodeTypes` instead of direct type annotation for nodeTypes registry to avoid strict type errors with custom nodes.

## WORLD-005 - 2026-02-01
- What I implemented: Connected RelationshipGraph to API data (Characters + Relationships). Installed @dagrejs/dagre for automatic graph layout. Added Relationship schemas (EntityType, RelationshipType) to frontend. Created mock handlers for /api/relationships. Implemented color-coded edges (green=ally, red=enemy, blue=family). Added edge animation for enemy/romantic relationships. Implemented node selection with MiniMap highlighting.
- Pattern discovered: When using useEdgesState with custom Edge types, you must specify the type parameter: `useEdgesState<Edge>([])`. Without it, TypeScript infers `never[]` which causes assignment errors.
- Gotcha for future: Avoid `satisfies` with optional properties in object literals when the type has optional fields. Instead, build the object conditionally: `const data: CharacterNodeData = { name }; if (archetype) data.archetype = archetype;`. This avoids type narrowing issues with undefined vs optional.

## WORLD-006 - 2026-02-01
- What I implemented: VERIFICATION PASS - Location hierarchy already fully implemented. Verified `parent_location_id` (line 187), `child_location_ids` (line 188), plus `add_child_location()`, `remove_child_location()`, `set_parent_location()`, and `_validate_hierarchy()` methods. LocationType enum has 26 types including CONTINENT, REGION, CITY, TOWN, VILLAGE, CASTLE, DUNGEON, TEMPLE, etc. All 17 Location tests pass in test_world_entities.py.
- Pattern discovered: Location.child_location_ids directly provides child IDs without needing a get_sub_locations() method. Returning full child Location objects would require repository lookup, which violates domain entity purity (entities should not depend on infrastructure). The current design correctly keeps hierarchy data as IDs.
- Gotcha for future: The test file is test_world_entities.py (not test_location.py as PRD suggested). Multiple world entities (WorldSetting, Faction, Location, HistoryEvent) are tested in a single comprehensive file.
