# Ralph Progress Log
Started: Sun Feb  1 12:27:10     2026
---

## WORLD-001 - 2026-02-01
- What I implemented: Added aliases, archetype, traits, appearance fields to CharacterProfile dataclass and CharacterSummary Pydantic schema. Updated frontend TypeScript schemas and mock handlers to match.
- Pattern discovered: CharacterProfile is a frozen dataclass (immutable), so new fields must have Optional types with None defaults for backward compatibility.
- Gotcha for future: When updating CharacterSummary schema, also update frontend/src/mocks/handlers.ts to include the new required fields, otherwise TypeScript type-check will fail.

## WORLD-002 - 2026-02-01
- What I implemented: Created CharacterProfileForm.tsx with react-hook-form and zod validation. Includes tag-based inputs for aliases and traits using Badge components. Uses shadcn/ui Input, Textarea, and Badge components. Name field is required with inline validation errors.
- Pattern discovered: When using zodResolver with strict TypeScript, the form values type must be explicitly defined and cast with `as Resolver<FormType>` to avoid type mismatch between zod's inferred optional fields and the form's runtime values.
- Gotcha for future: Use `useMemo` to stabilize array values from `form.watch()` when they're used in `useCallback` dependencies, otherwise ESLint warns about unstable deps causing re-renders.

## WORLD-003 - 2026-02-01
- What I implemented: Created Relationship entity with EntityType (5 types) and RelationshipType (12 types) enums. Implemented type compatibility validation (e.g., ROMANTIC requires CHARACTER entities). Created IRelationshipRepository protocol and InMemoryRelationshipRepository with entity-indexed lookups. Added CRUD API endpoints at /api/relationships with by-entity and between-entities queries. Wrote 33 unit tests covering all validation and query methods.
- Pattern discovered: World domain entities inherit from a base Entity class in src/contexts/world/domain/entities/entity.py that provides id, created_at, updated_at, version fields and domain event support. New entities should extend this base class.
- Gotcha for future: When creating new routers, remember to register them in TWO places in main_api_server.py's _register_legacy_routes: once without prefix and once with /api prefix for backward compatibility.

## WORLD-004 - 2026-02-01
- What I implemented: Created RelationshipGraph component using @xyflow/react v12. Added CharacterNode custom node with avatar placeholder, name, and archetype badge. Configured shadcn theme-matching styles for nodes, edges, handles, MiniMap, and Controls. Integrated graph into WorldPage replacing placeholder WorldMap.
- Pattern discovered: @xyflow/react v12 requires custom node data types to `extends Record<string, unknown>`, then create a `NodeType = Node<NodeData>` and use `NodeProps<NodeType>` for component props. This is different from older reactflow package patterns.
- Gotcha for future: The package name is `@xyflow/react` (already installed), not `reactflow`. The library was renamed. Use `satisfies NodeTypes` instead of direct type annotation for nodeTypes registry to avoid strict type errors with custom nodes.

## WORLD-005 - 2026-02-01
- What I implemented: Connected RelationshipGraph to API data (Characters + Relationships). Installed @dagrejs/dagre for automatic graph layout. Added Relationship schemas (EntityType, RelationshipType) to frontend. Created mock handlers for /api/relationships. Implemented color-coded edges (green=ally, red=enemy, blue=family). Added edge animation for enemy/romantic relationships. Implemented node selection with MiniMap highlighting.
- Pattern discovered: When using useEdgesState with custom Edge types, you must specify the type parameter: `useEdgesState<Edge>([])`. Without it, TypeScript infers `never[]` which causes assignment errors.
- Gotcha for future: Avoid `satisfies` with optional properties in object literals when the type has optional fields. Instead, build the object conditionally: `const data: CharacterNodeData = { name }; if (archetype) data.archetype = archetype;`. This avoids type narrowing issues with undefined vs optional.

## WORLD-006 - 2026-02-01
- What I implemented: VERIFICATION PASS - Location hierarchy already fully implemented. Verified `parent_location_id` (line 187), `child_location_ids` (line 188), plus `add_child_location()`, `remove_child_location()`, `set_parent_location()`, and `_validate_hierarchy()` methods. LocationType enum has 26 types including CONTINENT, REGION, CITY, TOWN, VILLAGE, CASTLE, DUNGEON, TEMPLE, etc. All 17 Location tests pass in test_world_entities.py.
- Pattern discovered: Location.child_location_ids directly provides child IDs without needing a get_sub_locations() method. Returning full child Location objects would require repository lookup, which violates domain entity purity (entities should not depend on infrastructure). The current design correctly keeps hierarchy data as IDs.
- Gotcha for future: The test file is test_world_entities.py (not test_location.py as PRD suggested). Multiple world entities (WorldSetting, Faction, Location, HistoryEvent) are tested in a single comprehensive file.

## WORLD-007 - 2026-02-01
- What I implemented: Created LocationTree.tsx recursive component using shadcn Collapsible. Added LocationType enum (27 types) with matching lucide-react icons. Implemented tree building from flat array with parent_location_id. Added keyboard accessibility (Enter/Space to select, Arrow keys to expand/collapse). Updated WorldLocationSchema with parent_location_id and child_location_ids fields. Created mock locations API with 3-level hierarchy (Continent > Region > City/Fortress).
- Pattern discovered: With `exactOptionalPropertyTypes: true` in tsconfig, optional props must use `prop: T | undefined` (explicit undefined) not `prop?: T` when passing potentially undefined values to child components. Also, avoid `new Map<K,V>()` constructor - use `Record<K,V>` object or `new Map(entries)` to avoid type inference issues with lucide-react's global type augmentation.
- Gotcha for future: The shadcn Collapsible component must be installed separately via `npx shadcn@latest add collapsible`. It's not included by default. The component is thin (just re-exports from @radix-ui/react-collapsible) but provides consistent styling hooks.

## WORLD-008 - 2026-02-01
- What I implemented: Created Item entity with ItemType (5 types: WEAPON/ARMOR/CONSUMABLE/KEY_ITEM/MISC) and ItemRarity (4 levels: COMMON/UNCOMMON/RARE/LEGENDARY) enums. Added inventory: List[str] to Character aggregate with give_item/remove_item/has_item methods. Created IItemRepository protocol and InMemoryItemRepository with type/rarity indexes. Added full CRUD API at /api/items plus /api/characters/{id}/give-item and /api/characters/{id}/remove-item/{item_id} endpoints. Wrote 35 unit tests covering entity validation, operations, factory methods, and serialization.
- Pattern discovered: Inventory management belongs on the Character aggregate (mutable state) rather than CharacterProfile (frozen dataclass). The aggregate pattern allows coordinating inventory changes with version updates and domain events.
- Gotcha for future: When creating router endpoints that cross domain boundaries (e.g., /characters/{id}/give-item relates to both items and characters), consider using a separate APIRouter (character_inventory_router) to keep concerns modular while still allowing registration under different prefixes.
