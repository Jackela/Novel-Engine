#!/usr/bin/env python3
"""
ChroniclerAgent Core Implementation
==================================

This module implements the ChroniclerAgent class, which serves as the narrative
transcription system for the StoryForge AI Interactive Story Engine. The ChroniclerAgent
transforms structured campaign logs into dramatic narrative stories that capture
the essence of any fictional universe.
"""

import json
import os
import re
import logging
import time
import random
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass, field
from src.event_bus import EventBus
from src.persona_agent import PersonaAgent
from shared_types import CharacterAction

from config_loader import get_config

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class CampaignEvent:
    """
    Represents a parsed event from the campaign log.
    
    Encapsulates all relevant information needed to generate narrative content
    for a specific event in the simulation timeline.
    """
    turn_number: int
    timestamp: str
    event_type: str
    description: str
    participants: List[str] = field(default_factory=list)
    faction_info: Dict[str, str] = field(default_factory=dict)
    action_details: Dict[str, Any] = field(default_factory=dict)
    raw_text: str = ""


@dataclass
class NarrativeSegment:
    """
    Represents a generated narrative segment for a specific event or turn.
    
    Contains the dramatic prose generated by the LLM along with metadata
    for combining segments into a cohesive story.
    """
    turn_number: int
    event_type: str
    narrative_text: str
    character_focus: List[str] = field(default_factory=list)
    faction_themes: List[str] = field(default_factory=list)
    tone: str = "dramatic"
    timestamp: str = ""


class ChroniclerAgent:
    """
    Core implementation of the narrative transcription system.
    
    The ChroniclerAgent transforms structured campaign logs into dramatic narrative prose.
    """
    
    def __init__(self, event_bus: EventBus, output_directory: Optional[str] = None, max_events_per_batch: Optional[int] = None, narrative_style: Optional[str] = None, character_names: Optional[List[str]] = None):
        """
        Initializes the ChroniclerAgent.

        Args:
            event_bus: An instance of the EventBus for decoupled communication.
            output_directory: Optional path to save generated narratives.
            max_events_per_batch: Optional maximum events per batch.
            narrative_style: Optional narrative style.
            character_names: Optional list of character names for story integration.
        """
        logger.info("Initializing ChroniclerAgent...")
        
        self.event_bus = event_bus
        self.narrative_segments: List[NarrativeSegment] = []

        try:
            config = get_config()
            self._config = config
        except Exception as e:
            logger.warning(f"Failed to load configuration, using defaults: {e}")
            self._config = None
        
        self.output_directory = output_directory or (self._config.chronicler.output_directory if self._config else None)
        self.max_events_per_batch = max_events_per_batch or (self._config.chronicler.max_events_per_batch if self._config else 50)
        self.narrative_style = narrative_style or (self._config.chronicler.narrative_style if self._config else "sci_fi_dramatic")
        self.character_names = character_names or []
        
        self.events_processed = 0
        self.narratives_generated = 0
        self.llm_calls_made = 0
        self.error_count = 0
        self.last_error_time: Optional[datetime] = None
        
        try:
            self._initialize_output_directory()
            self._initialize_narrative_templates()
            self.event_bus.subscribe("AGENT_ACTION_COMPLETE", self.handle_agent_action)
            self.event_bus.subscribe("SIMULATION_END", self.handle_simulation_end)
            logger.info("ChroniclerAgent initialized successfully and subscribed to events.")
        except Exception as e:
            logger.error(f"Failed to initialize ChroniclerAgent: {e}")
            raise ValueError(f"ChroniclerAgent initialization failed: {e}")
    
    def _initialize_output_directory(self) -> None:
        """Initializes and validates the output directory."""
        if not self.output_directory:
            logger.info("No output directory specified; narratives will be returned as strings.")
            return
        
        try:
            output_path = Path(self.output_directory)
            output_path.mkdir(parents=True, exist_ok=True)
            if not output_path.is_dir():
                raise ValueError(f"Output path is not a directory: {self.output_directory}")
            
            # Test write permissions
            (output_path / "test.tmp").touch()
            (output_path / "test.tmp").unlink()
            logger.info(f"Output directory validated: {self.output_directory}")
        except Exception as e:
            raise OSError(f"Output directory initialization failed: {e}")
    
    def _initialize_narrative_templates(self) -> None:
        """Initializes narrative generation templates."""
        self.narrative_templates = {
            'opening': "In the vast expanse of the cosmos, a story unfolds.",
            'agent_registration': "{character_name} of the {faction} has joined the conflict.",
            'character_action': "{character_name} chose to {action_type}. {action_description}",
            'turn_summary': "As turn {turn_number} concludes, the situation is as follows: {summary_text}",
            'closing': "Thus concludes this chapter of the saga."
        }
        self.faction_descriptions = {'Unknown': 'warriors of unclear allegiance'}
        logger.info("Narrative templates initialized.")
    
    def handle_agent_action(self, agent: PersonaAgent, action: Optional[CharacterAction]):
        """Handles the AGENT_ACTION_COMPLETE event."""
        if not action:
            return

        character_name = agent.character_data.get('name', 'Unknown')
        description = f"{character_name} decided to {action.action_type}"
        if action.reasoning:
            description += f": {action.reasoning}"

        event = CampaignEvent(
            turn_number=0, # This will need to be passed in the event payload
            timestamp=datetime.now().isoformat(),
            event_type='character_action',
            description=description
        )
        narrative_text = self._generate_event_narrative(event)
        if narrative_text:
            self.narrative_segments.append(NarrativeSegment(
                turn_number=event.turn_number,
                event_type=event.event_type,
                narrative_text=narrative_text
            ))

    def handle_simulation_end(self):
        """Handles the SIMULATION_END event, finalizing the narrative."""
        logger.info("Simulation ended, generating final narrative.")
        complete_story = self._combine_narrative_segments(self.narrative_segments)
        if self.output_directory:
            self._save_narrative_to_file(complete_story, "simulation_narrative")

    def _generate_event_narrative(self, event: CampaignEvent) -> str:
        """Generates narrative prose for a single event."""
        prompt = self._create_narrative_prompt(event)
        return self._call_llm(prompt)

    def _create_narrative_prompt(self, event: CampaignEvent) -> str:
        """Creates a contextual prompt for LLM narrative generation."""
        return f"Narrate this event dramatically: {event.description}"

    def _call_llm(self, prompt: str) -> str:
<<<<<<< Updated upstream
        """Makes an LLM API call for narrative generation."""
        logger.debug(f"ChroniclerAgent calling LLM with prompt: {prompt}")
        time.sleep(0.1) # Simulate API call
        self.llm_calls_made += 1
        # Fallback for now
        return f"A noteworthy event occurred: {prompt.split(':')[-1].strip()}"
=======
        """
        Make an LLM API call for narrative generation.
        
        This function follows the same pattern as PersonaAgent's _call_llm method
        and serves as the integration point for future LLM API connections.
        
        Args:
            prompt: Formatted prompt string for the LLM
            
        Returns:
            String response from the LLM (or simulated response for testing)
            
        Raises:
            Exception: If LLM API call fails
        """
        logger.debug(f"ChroniclerAgent calling LLM with prompt length: {len(prompt)} characters")
        
        # Simulate API call delay (development only)
        if os.getenv('DEVELOPMENT_MODE') == 'true':
            import asyncio
            import time
            time.sleep(0.1)
        
        # Track LLM calls
        self.llm_calls_made += 1
        
        # For Phase 4 implementation, return simulated dramatic responses
        # In actual deployment, this would connect to GPT, Claude, or another LLM service
        
        # Simulate realistic LLM response delay (development only)
        if os.getenv('DEVELOPMENT_MODE') == 'true':
            import time
            time.sleep(0.2)
        
        # Generate contextually appropriate response based on prompt content
        if "agent registration" in prompt.lower() or "joined the simulation" in prompt.lower():
            return self._generate_registration_response(prompt)
        elif "decided to" in prompt.lower() or "action" in prompt.lower():
            return self._generate_action_response(prompt)
        elif "turn" in prompt.lower() and "begins" in prompt.lower():
            return self._generate_turn_begin_response(prompt)
        elif "turn" in prompt.lower() and "completed" in prompt.lower():
            return self._generate_turn_end_response(prompt)
        else:
            return self._generate_general_response(prompt)
    
    def _generate_registration_response(self, prompt: str) -> str:
        """Generate a simulated LLM response for agent registration events."""
        # Always use injected character names if available - this is what the user requested
        character_name = "the operative"
        if self.character_names:
            character_name = random.choice(self.character_names)
        
        responses = [
            f"From the stellar forces emerged {character_name}, their presence marking another skilled individual ready for the mission ahead.",
            f"The roster expanded with {character_name}, another trained professional joining the galactic defense initiative.",
            f"With determination and expertise, {character_name} stepped forward to face the challenges that would define this operation.",
        ]
        return random.choice(responses)
    
    def _generate_action_response(self, prompt: str) -> str:
        """Generate a simulated LLM response for character action events."""
        # Always use injected character names if available - this ensures consistency with user requests
        character_name = "the operative"
        if self.character_names:
            character_name = random.choice(self.character_names)
            
        responses = [
            f"Faced with a critical decision, {character_name} assessed the situation and chose their strategic approach with calculated precision.",
            f"Drawing upon their training and experience, {character_name} moved forward with purpose, determined to accomplish their mission objectives.",
            f"With confidence born of expertise and dedication to their cause, {character_name} committed to their chosen course of action in the cosmic theater.",
        ]
        return random.choice(responses)
    
    def _generate_turn_begin_response(self, prompt: str) -> str:
        """Generate a simulated LLM response for turn beginning events."""
        responses = [
            "The mission parameters updated as new tactical opportunities emerged from the evolving situation, each moment offering strategic potential.",
            "Command protocols advanced to the next phase, with systematic coordination guiding the operational momentum forward.",
            "As conditions shifted across the operational theater, a new phase of the mission commenced with renewed focus.",
        ]
        return random.choice(responses)
    
    def _generate_turn_end_response(self, prompt: str) -> str:
        """Generate a simulated LLM response for turn ending events."""
        responses = [
            "The operational phase concluded with clear outcomes, establishing new baseline conditions for subsequent mission planning.",
            "Mission objectives were assessed and documented, with tactical results integrated into the ongoing strategic framework.",
            "The sequence completed successfully, with all teams prepared to advance to the next phase of coordinated operations.",
        ]
        return random.choice(responses)
    
    def _generate_general_response(self, prompt: str) -> str:
        """Generate a simulated LLM response for general events."""
        responses = [
            "Within the complex operational environment, each development contributed to the evolving strategic landscape.",
            "The interconnected mission framework adapted dynamically, with individual actions creating meaningful operational outcomes.",
            "Across the vast theater of galactic operations, coordinated efforts began to shape the direction of ongoing initiatives.",
        ]
        return random.choice(responses)
    
    def _post_process_narrative(self, llm_response: str, event: CampaignEvent) -> str:
        """
        Post-process the LLM response to ensure quality and consistency.
        
        Args:
            llm_response: Raw response from the LLM
            event: Original event for context
            
        Returns:
            Cleaned and formatted narrative text
        """
        # Clean up the response
        narrative = llm_response.strip()
        
        # Ensure proper sentence structure
        if not narrative.endswith(('.', '!', '?')):
            narrative += '.'
        
        # Add character names if they were involved but not mentioned
        if event.participants and not any(name.lower() in narrative.lower() for name in event.participants if name != "Unknown"):
            # Get valid character name (prefer injected names over "Unknown")
            char_name = None
            
            # First try to use a real participant name (not "Unknown")
            valid_participants = [name for name in event.participants if name != "Unknown" and name.strip()]
            if valid_participants:
                char_name = valid_participants[0]
            # If no valid participants but we have injected character names, use those
            elif self.character_names:
                char_name = random.choice(self.character_names)
            
            # Only prepend character context if we have a valid name
            if char_name:
                narrative = f"For {char_name}, " + narrative.lower()
        
        return narrative
    
    def _generate_fallback_narrative(self, event: CampaignEvent) -> str:
        """
        Generate a fallback narrative when LLM processing fails.
        
        Args:
            event: Campaign event to generate fallback for
            
        Returns:
            Basic narrative text based on templates
        """
        try:
            template_key = event.event_type
            style_key = 'sci_fi_dramatic'
            
            if template_key in self.narrative_templates and style_key in self.narrative_templates[template_key]:
                template = self.narrative_templates[template_key][style_key]
                
                # PRIORITY 1: Use injected character names (what the user requested)
                # PRIORITY 2: Use valid participants (not "Unknown")
                # PRIORITY 3: Generic fallback
                character_name = 'A warrior'
                if self.character_names:
                    character_name = random.choice(self.character_names)
                elif event.participants and event.participants[0] != 'Unknown':
                    character_name = event.participants[0]
                    
                format_vars = {
                    'character_name': character_name,
                    'faction': list(event.faction_info.values())[0] if event.faction_info else 'galactic forces',
                    'action_type': event.action_details.get('action_type', 'act'),
                    'turn_number': event.turn_number,
                    'action_description': event.action_details.get('reasoning', 'with strategic purpose'),
                    'character_description': self._get_faction_description(event.faction_info),
                    'motivation': 'duty and excellence',
                }
                
                return template.format(**format_vars)
            
        except Exception as e:
            logger.debug(f"Fallback narrative generation failed: {str(e)}")
        
        # Ultimate fallback with character name if available
        if self.character_names:
            character_name = random.choice(self.character_names)
            return f"In the darkness of space, {character_name} faced challenges that would echo through eternity."
        else:
            return f"In the darkness of space, events transpired that would echo through eternity."
    
    def _get_faction_description(self, faction_info: Dict[str, str]) -> str:
        """
        Get atmospheric description for a faction.
        
        Args:
            faction_info: Dictionary mapping characters to factions
            
        Returns:
            Atmospheric faction description
        """
        if not faction_info:
            return "A warrior of unknown allegiance"
        
        faction = list(faction_info.values())[0]
        
        for faction_key, description in self.faction_descriptions.items():
            if faction_key.lower() in faction.lower():
                return description
        
        return "a servant of the alliance's will"
    
    def _combine_narrative_segments(self, segments: List[NarrativeSegment], log_path: str) -> str:
        """
        Combine individual narrative segments into a cohesive story.
        
        Organizes segments chronologically and adds transitions, opening,
        and closing sections to create a complete narrative.
        
        Args:
            segments: List of narrative segments to combine
            log_path: Original log file path for context
            
        Returns:
            Complete narrative story as a single string
        """
        if not segments:
            return self._generate_empty_narrative(log_path)
        
        # Sort segments by turn number and event type
        sorted_segments = sorted(segments, key=lambda s: (s.turn_number, self._get_event_order(s.event_type)))
        
        # Build the complete story
        story_parts = []
        
        # Add opening section
        story_parts.append(self._generate_story_opening(sorted_segments, log_path))
        story_parts.append("\n\n")
        
        # Add narrative segments with appropriate transitions
        current_turn = -1
        for i, segment in enumerate(sorted_segments):
            # Add turn transition if needed
            if segment.turn_number != current_turn:
                if current_turn > -1:  # Not the first turn
                    story_parts.append("\n\n")
                current_turn = segment.turn_number
            
            # Add the narrative segment
            story_parts.append(segment.narrative_text)
            
            # Add spacing between segments
            if i < len(sorted_segments) - 1:
                story_parts.append(" ")
        
        # Add closing section
        story_parts.append("\n\n")
        story_parts.append(self._generate_story_closing(sorted_segments, log_path))
        
        complete_story = "".join(story_parts)
        
        logger.info(f"Combined {len(sorted_segments)} narrative segments into complete story")
        return complete_story
    
    def _get_event_order(self, event_type: str) -> int:
        """
        Get the ordering priority for different event types within a turn.
        
        Args:
            event_type: Type of event
            
        Returns:
            Integer ordering priority (lower numbers first)
        """
        order_map = {
            'initialization': 0,
            'turn_begin': 1,
            'agent_registration': 2,
            'character_action': 3,
            'general_event': 4,
            'error_event': 5,
            'turn_end': 6,
        }
        return order_map.get(event_type, 99)
    
    def _generate_story_opening(self, segments: List[NarrativeSegment], log_path: str) -> str:
        """
        Generate an atmospheric opening for the complete story.
        
        Args:
            segments: All narrative segments for context
            log_path: Original log file path
            
        Returns:
            Opening narrative text
        """
        # Extract context from segments
        all_characters = set()
        all_factions = set()
        
        for segment in segments:
            all_characters.update(segment.character_focus)
            all_factions.update(segment.faction_themes)
        
        # Use template system
        opening_template = self.narrative_templates['opening']['sci_fi_dramatic']
        
        context_vars = {
            'location': 'the contested battlefields of the galaxy',
            'campaign_id': os.path.basename(log_path)
        }
        
        opening = opening_template.format(**context_vars)
        
        # Use directly injected character names if available, otherwise parse from segments
        character_list = []
        if self.character_names:
            character_list = self.character_names[:3]  # Use injected names first
        elif all_characters:
            # Remove "Unknown" entries and use actual character names
            character_list = [char for char in list(all_characters)[:3] if char != "Unknown"]
        
        # Add character context based on available names
        if character_list:
            if len(character_list) == 1:
                opening += f" The chronicles focus upon {character_list[0]}, whose choices would echo through the void."
            elif len(character_list) == 2:
                opening += f" The fates of {character_list[0]} and {character_list[1]} intertwined in the crucible of war."
            elif len(character_list) > 2:
                opening += f" The destinies of {', '.join(character_list[:-1])}, and {character_list[-1]} converged in this tale of conflict."
        else:
            # Fallback if no valid character names found
            opening += f" The chronicles of galactic conflict unfold across the contested regions of space."
        
        return opening
    
    def _generate_story_closing(self, segments: List[NarrativeSegment], log_path: str) -> str:
        """
        Generate an atmospheric closing for the complete story.
        
        Args:
            segments: All narrative segments for context
            log_path: Original log file path
            
        Returns:
            Closing narrative text
        """
        closing_template = self.narrative_templates['closing']['sci_fi_dramatic']
        return closing_template
    
    def _generate_empty_narrative(self, log_path: str) -> str:
        """
        Generate a narrative for when no events are found in the log.
        
        Args:
            log_path: Path to the original log file
            
        Returns:
            Basic narrative for empty logs
        """
        return (
            "In the vast expanse of space, where conflict shapes destiny, "
            "this chronicle records a moment of stillness. Perhaps it was the calm "
            "before the storm, or perhaps it was the silence that follows great "
            "devastation. In the vastness of the galaxy, even silence carries weight.\n\n"
            f"Chronicle source: {os.path.basename(log_path)}\n"
            "Status: No significant events recorded\n\n"
            "In the name of peace, even the absence of war serves the greater purpose."
        )
    
    def _generate_error_narrative(self, log_path: str, error_message: str) -> str:
        """
        Generate a narrative when processing encounters errors.
        
        Args:
            log_path: Path to the original log file
            error_message: Description of the error encountered
            
        Returns:
            Error narrative with atmospheric flavor
        """
        return (
            "In the vast expanse of space, some chronicles are lost to "
            "the corrupting touch of chaos, their words scattered like ash on "
            "the solar winds. This record, though damaged, bears witness to "
            "events that even the Central Archives could not fully capture.\n\n"
            f"Chronicle source: {os.path.basename(log_path)}\n"
            f"Corruption detected: {error_message}\n\n"
            "Even incomplete records serve the truth. In darkness, "
            "we find light. In fragments, we discover purpose."
        )
    
    def _save_narrative_to_file(self, narrative: str, original_log_path: str) -> str:
        """
        Save the generated narrative to a file in the output directory.
        
        Args:
            narrative: Complete narrative text to save
            original_log_path: Path to the original log file for naming
            
        Returns:
            Path to the saved narrative file
            
        Raises:
            OSError: If file writing fails
        """
        try:
            # Generate output filename
            original_name = Path(original_log_path).stem
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_filename = f"{original_name}_narrative_{timestamp}.md"
            output_path = Path(self.output_directory) / output_filename
            
            # Create narrative header
            header = f"""# Campaign Chronicle: {original_name}
>>>>>>> Stashed changes

    def _combine_narrative_segments(self, segments: List[NarrativeSegment]) -> str:
        """Combines individual narrative segments into a cohesive story."""
        if not segments: return "No significant events to narrate."
        
        story = self.narrative_templates['opening'] + "\n\n"
        story += "\n\n".join([s.narrative_text for s in sorted(segments, key=lambda x: x.turn_number)])
        story += "\n\n" + self.narrative_templates['closing']
        return story

    def _save_narrative_to_file(self, narrative: str, base_filename: str) -> str:
        """Saves the generated narrative to a file."""
        filename = f"{base_filename}_narrative_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        output_path = Path(self.output_directory) / filename
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(f"# Narrative for {base_filename}\n\n{narrative}")
        
        logger.info(f"Narrative saved to: {output_path}")
        return str(output_path)

def example_usage():
    """Example usage of the ChroniclerAgent class."""
    print("ChroniclerAgent class is ready for use.")

if __name__ == "__main__":
    example_usage()